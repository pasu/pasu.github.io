<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://pasu.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pasu.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-06T14:26:42+00:00</updated><id>https://pasu.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal website of Peter Lu </subtitle><entry><title type="html">Traits</title><link href="https://pasu.github.io/blog/2025/Pbrt_Traits/" rel="alternate" type="text/html" title="Traits"/><published>2025-01-06T10:27:00+00:00</published><updated>2025-01-06T10:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/Pbrt_Traits</id><content type="html" xml:base="https://pasu.github.io/blog/2025/Pbrt_Traits/"><![CDATA[<h1 id="designing-traits-in-c">Designing Traits in C++</h1> <blockquote> <p>“Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine ‘policy’ or ‘implementation details’.” - Bjarne Stroustrup</p> </blockquote> <p>Traits are a powerful design pattern in C++ that allow you to associate compile-time metadata and behaviors with specific types. This tutorial explores how traits are used in the <code class="language-plaintext highlighter-rouge">pbrt</code> project to handle parameter parsing for various types, illustrating how traits can simplify type-specific behavior and make code cleaner and more extensible.</p> <hr/> <h2 id="example-overview-parameter-dictionary">Example Overview: Parameter Dictionary</h2> <p>The <code class="language-plaintext highlighter-rouge">ParameterDictionary</code> class manages parameters of various types, such as integers and floats. Each type has unique behaviors for conversion, retrieval, and metadata. Using traits, we can define these behaviors in a type-safe and organized way.</p> <hr/> <h2 id="step-1-define-the-traits-template">Step 1: Define the Traits Template</h2> <p>Begin by creating a generic template for traits:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">ParameterType</span> <span class="n">PT</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span> <span class="p">{};</span>
</code></pre></div></div> <p>This serves as the base structure. Specializations of this template will define type-specific behavior.</p> <hr/> <h2 id="step-2-create-specializations-for-each-type">Step 2: Create Specializations for Each Type</h2> <p>For every supported type, provide a specialization of <code class="language-plaintext highlighter-rouge">ParameterTypeTraits</code> to define its behavior and metadata. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">ParameterType</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">typeName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"integer"</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">nPerItem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="n">Convert</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>  <span class="c1">// Example conversion logic</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">GetValues</span><span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">ints</span><span class="p">;</span>  <span class="c1">// Retrieve integer values</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">ParameterType</span><span class="o">::</span><span class="n">Float</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">typeName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"float"</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">nPerItem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">float</span> <span class="n">Convert</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>  <span class="c1">// Example conversion logic</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">GetValues</span><span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">floats</span><span class="p">;</span>  <span class="c1">// Retrieve float values</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="key-components">Key Components:</h3> <ul> <li><strong><code class="language-plaintext highlighter-rouge">typeName</code></strong>: Describes the parameter type.</li> <li><strong><code class="language-plaintext highlighter-rouge">nPerItem</code></strong>: Specifies how many elements are in one item.</li> <li><strong><code class="language-plaintext highlighter-rouge">ReturnType</code></strong>: Defines the return type for retrieved values.</li> <li><strong><code class="language-plaintext highlighter-rouge">Convert</code></strong>: Handles type-specific conversion logic.</li> <li><strong><code class="language-plaintext highlighter-rouge">GetValues</code></strong>: Retrieves values from a <code class="language-plaintext highlighter-rouge">ParsedParameter</code> object.</li> </ul> <hr/> <h2 id="step-3-use-traits-in-generic-functions">Step 3: Use Traits in Generic Functions</h2> <p>The <code class="language-plaintext highlighter-rouge">ParameterDictionary</code> class can now leverage these traits to implement type-specific logic. For instance:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">ParameterType</span> <span class="n">PT</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">PT</span><span class="o">&gt;::</span><span class="n">ReturnType</span><span class="o">&gt;</span>
<span class="n">ParameterDictionary</span><span class="o">::</span><span class="n">lookupArray</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">traits</span> <span class="o">=</span> <span class="n">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">PT</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">lookupArray</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">traits</span><span class="o">::</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">PT</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">nPerItem</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">GetValues</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">Convert</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>This function:</p> <ul> <li>Extracts type-specific details from the corresponding <code class="language-plaintext highlighter-rouge">ParameterTypeTraits</code> specialization.</li> <li>Passes these details to another function for further processing.</li> </ul> <hr/> <h2 id="step-4-implement-helper-functions-using-traits">Step 4: Implement Helper Functions Using Traits</h2> <p>To implement core logic, a helper function can use the traits’ members:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ReturnType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">G</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span> <span class="n">ParameterDictionary</span><span class="o">::</span><span class="n">lookupArray</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span>
                                                         <span class="n">ParameterType</span> <span class="n">type</span><span class="p">,</span>
                                                         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typeName</span><span class="p">,</span>
                                                         <span class="kt">int</span> <span class="n">nPerItem</span><span class="p">,</span> <span class="n">G</span> <span class="n">getValues</span><span class="p">,</span>
                                                         <span class="n">C</span> <span class="n">convert</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">*</span><span class="n">p</span> <span class="o">:</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">typeName</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">returnArray</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">getValues</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">nPerItem</span><span class="p">,</span> <span class="n">convert</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation">Explanation:</h3> <ul> <li><strong><code class="language-plaintext highlighter-rouge">getValues</code></strong> and <strong><code class="language-plaintext highlighter-rouge">convert</code></strong> are passed as arguments derived from the traits.</li> <li>They enable type-specific operations without requiring hard-coded logic.</li> </ul> <hr/> <h2 id="step-5-ensure-traits-members-are-static">Step 5: Ensure Traits Members Are Static</h2> <p>For this design to work seamlessly, traits’ functions such as <code class="language-plaintext highlighter-rouge">Convert</code> and <code class="language-plaintext highlighter-rouge">GetValues</code> should be <code class="language-plaintext highlighter-rouge">static</code>. This allows them to be called without creating an instance of <code class="language-plaintext highlighter-rouge">ParameterTypeTraits</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">traits</span><span class="o">::</span><span class="n">GetValues</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// Works because GetValues is static</span>
</code></pre></div></div> <hr/> <h2 id="why-use-traits">Why Use Traits?</h2> <h3 id="advantages-of-the-traits-pattern">Advantages of the Traits Pattern:</h3> <ol> <li><strong>Decoupling Logic</strong>: Each type’s behavior is encapsulated within its specialization.</li> <li><strong>Compile-Time Optimizations</strong>: Decisions based on type occur at compile time, improving efficiency.</li> <li><strong>Reusability</strong>: Shared logic for type-specific operations can be reused across functions.</li> <li><strong>Extensibility</strong>: Adding support for a new type requires only a new specialization.</li> </ol> <hr/> <h2 id="extending-the-traits">Extending the Traits</h2> <p>For instance, to support <code class="language-plaintext highlighter-rouge">std::string</code> parameters, add another specialization:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">ParameterType</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">typeName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"string"</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">nPerItem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Convert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// Example conversion logic</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">GetValues</span><span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">strings</span><span class="p">;</span>  <span class="c1">// Retrieve string values</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>This integrates seamlessly with functions like <code class="language-plaintext highlighter-rouge">lookupArray</code> without requiring further changes.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>The traits pattern offers a clean and extensible approach to managing type-specific behavior in C++. By encapsulating type logic in traits, you can achieve strong type safety, separation of concerns, and efficient compile-time operations. Use this tutorial as a guide to designing your own traits for robust and maintainable C++ code.</p>]]></content><author><name></name></author><category term="C++"/><category term="ModernC++"/><category term="Pbrt"/><summary type="html"><![CDATA[Designing Traits in C++]]></summary></entry><entry><title type="html">DDG Curvature</title><link href="https://pasu.github.io/blog/2025/DDG_Curvature/" rel="alternate" type="text/html" title="DDG Curvature"/><published>2025-01-04T20:27:00+00:00</published><updated>2025-01-04T20:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/DDG_Curvature</id><content type="html" xml:base="https://pasu.github.io/blog/2025/DDG_Curvature/"><![CDATA[<h3 id="exploring-curvature">Exploring Curvature</h3> <p>A <strong>continuous curve</strong> is a fundamental concept in mathematics, appearing in fields ranging from physics to computer graphics. Understanding its properties, such as the tangent, normal, and curvature, provides valuable insights into its geometry and behavior. Let’s delve into these ideas in detail.</p> <hr/> <h3 id="what-is-a-continuous-curve">What Is a Continuous Curve?</h3> <p>A <strong>parameterized curve</strong> in the 2D plane can be defined as a mapping:</p> \[\gamma(s): [0, L] \to \mathbb{R}^2\] <p>where:</p> <ul> <li><strong>s</strong> is the parameter, often representing arc length, defined in the interval \([0, L]\).</li> <li>\(\gamma(s) = (x(s), y(s))\) specifies the position of a point on the curve.</li> </ul> <hr/> <h3 id="tangent-vector-of-a-curve">Tangent Vector of a Curve</h3> <p>The <strong>tangent vector</strong> gives the direction of the curve at a specific point \(\gamma(s)\). It is defined as the derivative of the curve with respect to the parameter \(s\):</p> \[T(s) = \frac{d}{ds} \gamma(s) = \left(\frac{dx}{ds}, \frac{dy}{ds}\right)\] <p>If the curve is <strong>arc-length parameterized</strong> (where \(s\) directly measures the distance along the curve).</p> <p>The tangent vector points in the direction in which the curve is moving at \(\gamma(s)\), making it an essential tool for understanding the geometry of the curve.</p> <hr/> <h3 id="normal-vector-of-a-curve">Normal Vector of a Curve</h3> <p>The <strong>normal vector</strong> is perpendicular to the tangent vector and provides the “sideways” direction of the curve at a given point. In 2D, the normal vector is obtained by performing a quarter-turn rotation (90° counter-clockwise) on the tangent vector. This is achieved using the <strong>rotation operator</strong>:</p> \[\mathcal{R}(x, y) = (-y, x)\] <p>Thus, for a tangent vector \(T(s) = (T_x(s), T_y(s))\), the normal vector \(N(s)\) is:</p> \[N(s) = (-T_y(s), T_x(s))\] <p>The tangent and normal vectors satisfy the following:</p> <ul> <li>They are orthogonal: \(T(s) \cdot N(s) = 0\).</li> <li>\(T(s)\) represents the direction of the curve’s motion, while \(N(s)\) represents the direction perpendicular to it.</li> </ul> <hr/> <h3 id="curvature-of-a-curve">Curvature of a Curve</h3> <p>The <strong>curvature</strong> quantifies how sharply a curve bends at a given point. It is defined as the rate of change of the tangent vector \(T(s)\) with respect to the arc-length parameter \(s\):</p> \[\kappa(s) = \left\|\frac{dT(s)}{ds}\right\|\] <p>In simple terms, curvature measures how quickly the direction of the tangent vector changes as you move along the curve.</p> <h4 id="geometric-interpretation">Geometric Interpretation</h4> <ul> <li><strong>High Curvature</strong>: The curve bends sharply.</li> <li><strong>Low Curvature</strong>: The curve is almost straight.</li> <li>For a <strong>circle</strong> of radius \(r\), the curvature is constant everywhere: \(\kappa = \frac{1}{r}\).</li> </ul> <h4 id="signed-curvature">Signed Curvature</h4> <p>In 2D, curvature can also carry a <strong>sign</strong> to indicate the direction of bending:</p> <ul> <li><strong>Positive curvature</strong>: The curve bends counter-clockwise.</li> <li><strong>Negative curvature</strong>: The curve bends clockwise.</li> </ul> <p>The signed curvature is often computed as:</p> \[\kappa(s) = \frac{\det(\gamma'(s), \gamma''(s))}{\|\gamma'(s)\|^3}\] <p>where \(\det(\gamma'(s), \gamma''(s))\) is the determinant of the tangent and second derivative vectors, capturing the orientation of the bend.</p> <hr/> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/smooth_curve-480.webp 480w,/assets/img/DDG/smooth_curve-800.webp 800w,/assets/img/DDG/smooth_curve-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/smooth_curve.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="summary-of-relationships">Summary of Relationships</h3> <ol> <li><strong>Tangent Vector \(T(s)\)</strong>: Indicates the direction of motion.</li> <li><strong>Normal Vector \(N(s)\)</strong>: Points perpendicular to \(T(s)\), describing the sideways direction.</li> <li><strong>Curvature \(\kappa(s)\)</strong>: Measures the rate of bending of the curve.</li> </ol> <p>These elements together form the core tools for studying and analyzing the geometry of curves, enabling applications from path planning in robotics to the study of dynamic systems.</p> <hr/> <h3 id="discrete-curvature">Discrete Curvature</h3> <p>A <strong>discrete curve</strong> is a piecewise linear parameterized curve, defined as a sequence of vertices \(\{\gamma_i\}\), connected by straight line segments. Unlike smooth curves, discrete curves do not have a continuous tangent or curvature, which poses challenges in defining curvature. Direct application of curvature definitions from smooth curves results in values that are either zero (for straight segments) or infinite (at sharp corners).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/discrete_curve-480.webp 480w,/assets/img/DDG/discrete_curve-800.webp 800w,/assets/img/DDG/discrete_curve-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/discrete_curve.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>To address this, we use <strong>approximations of curvature</strong> based on discrete geometry concepts.</p> <h4 id="turning-angle">Turning Angle</h4> <p>One approach to defining discrete curvature is through the <strong>turning angle</strong> at each vertex of the curve. For a vertex \(\gamma_i\), the turning angle is defined as the angle between the vectors \((\gamma_i - \gamma_{i-1})\) and \((\gamma_{i+1} - \gamma_i)\):</p> \[\theta_i = \text{angle}(\gamma_i - \gamma_{i-1}, \gamma_{i+1} - \gamma_i).\] <p>The curvature at vertex \(i\) can then be approximated as the turning angle normalized by some measure, such as the arc length between the vertices. For simplicity:</p> \[\kappa_i = \theta_i,\] <p>This mathematical formulation expresses the <strong>variation of the curve length</strong> due to a perturbation \(\eta(s)\). Let’s improve the explanation around this concept to clarify its significance and provide proper context.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/turning_angle-480.webp 480w,/assets/img/DDG/turning_angle-800.webp 800w,/assets/img/DDG/turning_angle-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/turning_angle.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h4 id="length-variation-of-a-curve">Length Variation of a Curve</h4> <p>Given a smooth parameterized curve \(\gamma(s)\), we consider a perturbation of the curve by a smooth function \(\eta(s)\), which modifies the original curve as:</p> \[\gamma_\epsilon(s) = \gamma(s) + \epsilon \eta(s),\] <p>where \(\epsilon\) is a small parameter. The goal is to evaluate how the length of the curve changes under this perturbation at \(\epsilon = 0\).</p> <h5 id="length-functional">Length Functional</h5> <p>The length of the perturbed curve \(\gamma_\epsilon(s)\) is given by:</p> \[\text{Length}(\gamma_\epsilon) = \int_0^{L} \|\gamma_\epsilon'(s)\| \, ds.\] <p>Differentiating the length functional with respect to \(\epsilon\) and evaluating at \(\epsilon = 0\), we get the length variation:</p> \[\frac{d}{d\epsilon}\Big|_{\epsilon=0} \text{Length}(\gamma_\epsilon) = -\int_0^L \langle \eta(s), \kappa(s)N(s) \rangle \, ds,\] <p>where:</p> <ul> <li>\(\eta(s)\) is the perturbation function, representing the deformation of the curve.</li> <li>\(\kappa(s)\) is the curvature of the curve at each point.</li> <li>\(N(s)\) is the unit normal vector to the curve.</li> <li>\(\langle \cdot, \cdot \rangle\) denotes the dot product in \(\mathbb{R}^2\).</li> </ul> <h5 id="geometric-interpretation-1">Geometric Interpretation</h5> <p>This formula reveals that the change in length depends on:</p> <ol> <li>The <strong>projection of the perturbation</strong> \(\eta(s)\) onto the normal direction \(N(s)\).</li> <li>The <strong>curvature</strong> \(\kappa(s)\) of the curve.</li> </ol> <p>Therefore, the motion that most quickly decreases length is \(\eta = \kappa N\). And it becomes much easier in the discrete setting: just take the gradient of length with respect to vertex positions.</p> <p>In the discrete setting, the motion that minimizes the length of a curve at each vertex can be expressed in terms of the <strong>turning angle</strong> at that vertex. Specifically, the gradient of the curve length becomes proportional to \(2 \sin(\theta_i / 2) N_i\), where \(\theta_i\) is the angle between the adjacent edges at vertex \(i\), and \(N_i\) is the normal direction at that vertex. Let’s break this down:</p> <h5 id="discrete-length-and-turning-angle">Discrete Length and Turning Angle</h5> <p>For a discrete curve, the total length is:</p> \[\text{Length}(\gamma) = \sum_{i=1}^n \|\gamma_i - \gamma_{i-1}\|,\] <p>The turning angle \(\theta_i\) at a vertex is the angle between the two adjacent edges:</p> \[\theta_i = \text{angle}(\gamma_i - \gamma_{i-1}, \gamma_{i+1} - \gamma_i).\] <h5 id="gradient-of-length">Gradient of Length</h5> <p>At each vertex, the gradient of the length \(\nabla_{\gamma_i} \text{Length}(\gamma)\) (from earlier) is derived as:</p> \[\nabla_{\gamma_i} \text{Length}(\gamma) = \frac{\gamma_i - \gamma_{i-1}}{\|\gamma_i - \gamma_{i-1}\|} + \frac{\gamma_i - \gamma_{i+1}}{\|\gamma_{i+1} - \gamma_i\|}.\] <p>This gradient can be interpreted geometrically in terms of \(\theta_i\) and the <strong>unit normal vector</strong> \(N_i\). It simplifies to:</p> \[\nabla_{\gamma_i} \text{Length}(\gamma) = 2 \sin\left(\frac{\theta_i}{2}\right) N_i,\] <p>where:</p> <ul> <li>\(\theta_i/2\) is half the turning angle.</li> <li>\(N_i\) is the inward or outward unit normal at vertex \(i\), depending on the curve’s orientation.</li> </ul> <p>The gradient of length is equal to the curvature times the normal, we have the second equivalent definition as length variation:</p> \[\kappa_i^B = 2 \sin\left(\frac{\theta_i}{2}\right)\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/length_variation-480.webp 480w,/assets/img/DDG/length_variation-800.webp 800w,/assets/img/DDG/length_variation-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/length_variation.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="relationship-between-the-two">Relationship Between the Two</h4> <p>For small \(\theta_i\) (when the curve bends only slightly):</p> \[\kappa_i^B \approx \theta_i,\] <p>since \(\sin(\theta_i / 2) \approx \theta_i / 2\) when \(\theta_i\) is small.</p> <p>This shows that the <strong>length variation</strong> curvature (\(\kappa_i^B\)) is a refined and scaled version of the <strong>turning angle</strong> curvature (\(\kappa_i^A\)), particularly useful when considering the discrete gradient of the curve’s length.</p> <hr/> <h4 id="steiner-formula-for-smooth-curves">Steiner Formula for Smooth Curves</h4> <p>The <strong>Steiner Formula</strong> provides a powerful connection between the geometry of a curve and how its length changes as the curve is offset in the normal direction. Here’s the explanation in detail:</p> <p>If a smooth curve \(\gamma\) is moved at a constant distance \(\epsilon\) in the <strong>normal direction</strong>, then the new length of the curve is given by:</p> \[\text{Length}(\gamma + \epsilon N) = \text{Length}(\gamma) - \epsilon \int_0^L \kappa(s) \, ds.\] <h5 id="key-insights">Key Insights:</h5> <ol> <li><strong>Offset Motion</strong>: Moving in the normal direction affects the length of the curve proportionally to the <strong>total curvature</strong>, i.e., the integral of \(\kappa(s)\) along the arc length.</li> <li><strong>Geometric Meaning</strong>: If the curve bends a lot (high curvature), offsetting it decreases the length more significantly. For flat or nearly straight curves, the change in length is minimal.</li> </ol> <h5 id="discrete-setting">Discrete Setting</h5> <p>In discrete curves, we offset each edge segment of the curve. The challenge lies in connecting these new offset segments consistently. Several natural strategies include:</p> <h6 id="a-circular-arc-of-radius-epsilon">A. Circular Arc of Radius \(\epsilon\):</h6> <ul> <li>Each corner is joined with a small arc, mimicking the curvature of the original smooth curve.</li> <li>This approach approximates the smooth curve behavior, including how curvature influences the overall length.</li> </ul> <h6 id="b-straight-line-connection">B. Straight Line Connection:</h6> <ul> <li>Offset segments are connected by straight lines.</li> <li>Simpler to implement but less faithful to smooth curvature effects.</li> </ul> <h6 id="c-extending-edges-until-intersection">C. Extending Edges Until Intersection:</h6> <ul> <li>Extend the offset edges until they intersect, creating natural meeting points between segments.</li> <li>Reflects how many engineering applications handle discrete curves but introduces additional sharp features.</li> </ul> <p>These equations express the <strong>length variation</strong> of a discrete curve under different curvature approximations, using turning angle (\(\theta_i\)) and its trigonometric variants. Let’s clarify the context and interpretation:</p> \[\text{Length}_A = \text{Length}(\gamma) - \epsilon \sum_i \theta_i\] \[\text{Length}_B = \text{Length}(\gamma) - \epsilon \sum_i 2 \sin\left(\frac{\theta_i}{2}\right)\] \[\text{Length}_C = \text{Length}(\gamma) - \epsilon \sum_i 2 \tan\left(\frac{\theta_i}{2}\right)\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/stein-480.webp 480w,/assets/img/DDG/stein-800.webp 800w,/assets/img/DDG/stein-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/stein.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h5 id="small-theta_i-approximation">Small \(\theta_i\) Approximation</h5> <p>For small \(\theta_i\), we can use:</p> \[\sin\left(\frac{\theta_i}{2}\right) \approx \tan\left(\frac{\theta_i}{2}\right) \approx \frac{\theta_i}{2}.\] <p>This makes all three formulas effectively equivalent when the turning angles are small. However, for larger angles, \(\sin(\theta_i / 2)\) and \(\tan(\theta_i / 2)\) offer better approximations.</p> <hr/> <h4 id="osculating-circle">Osculating Circle</h4> <p>The <strong>osculating circle</strong> is the circle that best approximates a smooth curve at a given point.</p> <ul> <li>Its radius matches the radius of curvature of the curve, i.e., it captures the curve’s local bending behavior.</li> <li>The <strong>curvature</strong> \(\kappa\) of the curve is the reciprocal of the osculating circle’s radius:</li> </ul> \[\kappa = \frac{1}{R}.\] <p>This geometric approach provides a simple and intuitive way to understand curvature as the “tightness” of bending.</p> <p>In the discrete setting, an analogous concept involves the <strong>circumcircle</strong> passing through three consecutive vertices of a discrete curve:</p> \[\kappa_i^D = \frac{1}{R_i} = \frac{2 \sin(\theta_i)}{\omega_i}\] <p>where \(R_i\) is the circumcircle radius for the vertices \(v_{i-1}, v_i, v_{i+1}\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/osculating-480.webp 480w,/assets/img/DDG/osculating-800.webp 800w,/assets/img/DDG/osculating-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/osculating.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h5 id="comparison-with-other-curvature-approximations">Comparison with Other Curvature Approximations</h5> <p>The osculating circle method differs from previous discrete curvature approximations, such as the turning angle or length variation, in its direct connection to geometric properties:</p> <ol> <li><strong>Turning Angle</strong>: Measures the rate of direction change without explicit geometric constructs.</li> <li><strong>Length Variation</strong>: Relates to changes in curve length when offset, often smoothed over multiple vertices.</li> <li><strong>Osculating Circle</strong>: Provides a direct geometric measure based on the localized radius of bending, connecting smoothly to the smooth setting.</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/four-480.webp 480w,/assets/img/DDG/four-800.webp 800w,/assets/img/DDG/four-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/four.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h4 id="key-properties-of-curvature-flows">Key Properties of Curvature Flows</h4> <p>When studying curvature-based flows on curves, there are several fundamental properties that help in understanding their behavior:</p> <ol> <li> <p><strong>Total Curvature</strong> <strong>Property</strong>: The <strong>total curvature</strong> remains constant throughout the flow.</p> <ul> <li>For smooth curves, the total curvature is \(\int_0^L \kappa(s) \, ds\).</li> <li>In the discrete case, the total curvature is typically expressed as \(\sum_i \kappa_i\) (using one of the discrete definitions of curvature).</li> <li>This conservation is tied to intrinsic geometric properties of the curve.</li> </ul> </li> <li> <p><strong>Drift</strong> <strong>Property</strong>: The center of mass of the curve does not drift from the origin during the flow.</p> <ul> <li> <p>For a parameterized curve \(\gamma(s)\), the center of mass is given by:</p> \[\text{Center of Mass} = \frac{1}{L} \int_0^L \gamma(s) \, ds.\] </li> <li> <p>The non-drifting property ensures that the motion of the curve due to curvature flow does not introduce translational shifts in the overall system.</p> </li> </ul> </li> <li> <p><strong>Roundness (Stationary for Circular Curves)</strong> <strong>Property</strong>: Up to rescaling, the flow is stationary for circular curves.</p> <ul> <li>Circular curves represent an equilibrium state under curvature flows because their curvature \(\kappa = 1/r\) is constant everywhere.</li> <li>This means that circular shapes simply contract (or expand) uniformly during the flow but retain their geometry.</li> <li>The radius of the circle may change over time, but the overall shape remains a perfect circle.</li> </ul> </li> </ol> <table> <thead> <tr> <th style="text-align: left"> </th> <th style="text-align: center">Total</th> <th style="text-align: right">Drift</th> <th style="text-align: right">Round</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">\(\kappa^A\)</td> <td style="text-align: center">√</td> <td style="text-align: right">×</td> <td style="text-align: right">×</td> </tr> <tr> <td style="text-align: left">\(\kappa^B\)</td> <td style="text-align: center">×</td> <td style="text-align: right">√</td> <td style="text-align: right">×</td> </tr> <tr> <td style="text-align: left">\(\kappa^D\)</td> <td style="text-align: center">×</td> <td style="text-align: right">×</td> <td style="text-align: right">√</td> </tr> </tbody> </table> <p>No choice of discrete curvature simultaneously captures all three properties of the smooth flow.</p> <h3 id="conclusion">Conclusion</h3> <p>Curvature and its related properties, such as tangent vectors, normal vectors, and curvature flows, provide a fundamental framework for understanding the geometry of curves in both smooth and discrete settings. Key concepts like the Steiner formula, osculating circle, and curvature approximations help quantify and analyze the bending and motion of curves. While no single discrete curvature captures all the properties of smooth flows, these tools collectively enable deeper exploration and application of geometric principles in various fields, from robotics to computer graphics.</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[Exploring Curvature]]></summary></entry><entry><title type="html">Tokenizer and ParserTarget</title><link href="https://pasu.github.io/blog/2025/Pbrt_Token/" rel="alternate" type="text/html" title="Tokenizer and ParserTarget"/><published>2025-01-04T15:27:00+00:00</published><updated>2025-01-04T15:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/Pbrt_Token</id><content type="html" xml:base="https://pasu.github.io/blog/2025/Pbrt_Token/"><![CDATA[<p>PBRT (Physically Based Rendering Toolkit) is a well-regarded open-source library in computer graphics, renowned for its comprehensive rendering capabilities. Two key components in PBRT’s input pipeline are the <code class="language-plaintext highlighter-rouge">Tokenizer</code> and <code class="language-plaintext highlighter-rouge">ParserTarget</code>. Together, they enable the parsing and interpretation of scene descriptions. This post delves into their design, functionality, and interplay, showcasing PBRT’s sophisticated input processing mechanism.</p> <hr/> <h2 id="understanding-the-tokenizer">Understanding the Tokenizer</h2> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> class converts raw input streams into manageable units called tokens. Alongside the <code class="language-plaintext highlighter-rouge">Token</code> structure, it performs lexical analysis, the first step in parsing scene descriptions.</p> <h3 id="the-token-structure">The <code class="language-plaintext highlighter-rouge">Token</code> Structure</h3> <p>The <code class="language-plaintext highlighter-rouge">Token</code> structure represents an individual piece of meaningful data extracted from the input. Its primary components include:</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::string_view token</code></strong>: A lightweight, non-owning reference to the token’s string content.</li> <li><strong><code class="language-plaintext highlighter-rouge">FileLoc loc</code></strong>: An object that records the file, line, and column where the token originates, aiding in debugging and error reporting.</li> </ul> <h4 id="key-features">Key Features</h4> <ol> <li><strong>Efficient String Handling</strong>: By leveraging <code class="language-plaintext highlighter-rouge">std::string_view</code>, it minimizes unnecessary string copying.</li> <li><strong>Error Context</strong>: The <code class="language-plaintext highlighter-rouge">FileLoc</code> ensures precise error reporting by providing detailed location information.</li> </ol> <h4 id="example">Example</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Token</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">token</span><span class="p">,</span> <span class="n">FileLoc</span> <span class="n">loc</span><span class="p">)</span> <span class="o">:</span> <span class="n">token</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="n">loc</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">+</span> <span class="s">" at "</span> <span class="o">+</span> <span class="n">loc</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>This design ensures tokens are both lightweight and contextually rich.</p> <h3 id="the-tokenizer-class">The <code class="language-plaintext highlighter-rouge">Tokenizer</code> Class</h3> <h4 id="core-responsibilities">Core Responsibilities</h4> <ol> <li><strong>Lexical Analysis</strong>: Breaks down raw input into tokens.</li> <li><strong>Error Handling</strong>: Supports user-defined callbacks for error reporting.</li> <li><strong>Stream Management</strong>: Processes input from files and strings alike.</li> </ol> <h4 id="key-methods">Key Methods</h4> <ul> <li> <p><strong>Token Extraction</strong>: The <code class="language-plaintext highlighter-rouge">Next</code> method retrieves the next token, handling whitespace, comments, and escaped characters:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">Next</span><span class="p">();</span>
</code></pre></div> </div> </li> <li> <p><strong>Factory Methods</strong>: <code class="language-plaintext highlighter-rouge">CreateFromFile</code> and <code class="language-plaintext highlighter-rouge">CreateFromString</code> initialize a <code class="language-plaintext highlighter-rouge">Tokenizer</code> for different input sources.</p> </li> <li> <p><strong>Error Callback</strong>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">errorCallback</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </li> </ul> <h4 id="efficiency-and-flexibility">Efficiency and Flexibility</h4> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> is designed for performance and adaptability, with memory-efficient string handling and support for PBRT’s custom syntax.</p> <hr/> <h2 id="exploring-the-parsertarget">Exploring the ParserTarget</h2> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> interprets tokens produced by the <code class="language-plaintext highlighter-rouge">Tokenizer</code>, converting them into structured representations of scene data. It abstracts token interpretation from PBRT’s rendering logic.</p> <h3 id="design-philosophy">Design Philosophy</h3> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> provides an interface for processing structured data, ensuring a clear separation of concerns. Its primary functions include:</p> <ol> <li><strong>Data Interpretation</strong>: Transforms token sequences into meaningful constructs like objects and materials.</li> <li><strong>Modularity</strong>: Decouples tokenization from high-level parsing and semantic processing.</li> </ol> <h3 id="key-methods-1">Key Methods</h3> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">AddShape</code></strong>: Handles shape declarations by accepting a name and parameters:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">AddShape</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">ParsedParameterVector</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">AddMaterial</code></strong>: Processes material definitions:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">AddMaterial</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">ParsedParameterVector</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">AddLight</code></strong>: Interprets light source specifications:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">AddLight</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">ParsedParameterVector</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div> </div> </li> </ol> <h3 id="implementation-details">Implementation Details</h3> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> acts as a base class, enabling developers to create specialized implementations tailored to specific rendering needs. This design fosters:</p> <ul> <li><strong>Customizability</strong>: Developers can extend functionality without modifying the core implementation.</li> <li><strong>Maintainability</strong>: Encapsulation reduces dependencies and enhances code clarity.</li> </ul> <hr/> <h2 id="how-they-work-together">How They Work Together</h2> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> and <code class="language-plaintext highlighter-rouge">ParserTarget</code> collaborate in a streamlined pipeline:</p> <ol> <li><strong>Tokenization</strong>: The <code class="language-plaintext highlighter-rouge">Tokenizer</code> processes input streams and produces tokens.</li> <li><strong>Parsing</strong>: The <code class="language-plaintext highlighter-rouge">ParserTarget</code> interprets these tokens according to PBRT’s syntax.</li> <li><strong>Scene Construction</strong>: Parsed data updates PBRT’s internal representation of the scene.</li> </ol> <p>This modular design exemplifies sound software engineering, with each component fulfilling a distinct role.</p> <h3 id="comparison-to-json-or-xml">Comparison to JSON or XML</h3> <table> <thead> <tr> <th style="text-align: left">Aspect</th> <th style="text-align: center">Tokenizer in PBRT</th> <th style="text-align: right">JSON</th> <th style="text-align: right">XML</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Syntax</strong></td> <td style="text-align: center">Custom, minimal</td> <td style="text-align: right">Rigid, hierarchical</td> <td style="text-align: right">Verbose, hierarchical</td> </tr> <tr> <td style="text-align: left"><strong>Readability</strong></td> <td style="text-align: center">High for humans</td> <td style="text-align: right">Medium</td> <td style="text-align: right">Low</td> </tr> <tr> <td style="text-align: left"><strong>Extensibility</strong></td> <td style="text-align: center">Highly flexible</td> <td style="text-align: right">Moderate</td> <td style="text-align: right">Moderate</td> </tr> <tr> <td style="text-align: left"><strong>Parsing Complexity</strong></td> <td style="text-align: center">Lightweight</td> <td style="text-align: right">Moderate</td> <td style="text-align: right">Heavy</td> </tr> <tr> <td style="text-align: left"><strong>Expressiveness</strong></td> <td style="text-align: center">Domain-specific</td> <td style="text-align: right">Generic</td> <td style="text-align: right">Generic</td> </tr> <tr> <td style="text-align: left"><strong>Error Handling</strong></td> <td style="text-align: center">Customized</td> <td style="text-align: right">Standardized</td> <td style="text-align: right">Standardized</td> </tr> </tbody> </table> <h3 id="why-not-json-or-xml">Why Not JSON or XML?</h3> <p>PBRT’s scene descriptions require a format optimized for:</p> <ul> <li>Inline mathematical expressions.</li> <li>Metadata and comments.</li> <li>Compact, domain-specific configurations.</li> </ul> <p>General-purpose formats like JSON or XML are less suited for these needs, making a custom <code class="language-plaintext highlighter-rouge">Tokenizer</code> more appropriate.</p> <hr/> <h2 id="design-patterns-and-principles">Design Patterns and Principles</h2> <h3 id="factory-method-pattern">Factory Method Pattern</h3> <p>Used in the <code class="language-plaintext highlighter-rouge">Tokenizer</code> for creating instances from different input sources.</p> <h3 id="strategy-pattern">Strategy Pattern</h3> <p>Error callbacks decouple error handling from tokenization logic.</p> <h3 id="single-responsibility-principle">Single Responsibility Principle</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Tokenizer</code>: Handles lexical analysis.</li> <li><code class="language-plaintext highlighter-rouge">ParserTarget</code>: Focuses on semantic interpretation.</li> </ul> <h3 id="openclosed-principle">Open/Closed Principle</h3> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> allows new functionality through inheritance without modifying the base class.</p> <hr/> <h2 id="lessons-for-c-developers">Lessons for C++ Developers</h2> <ol> <li><strong>Efficient String Management</strong>: Leverage <code class="language-plaintext highlighter-rouge">std::string_view</code> for minimal overhead.</li> <li><strong>Contextual Error Reporting</strong>: Use tools like <code class="language-plaintext highlighter-rouge">FileLoc</code> for precise debugging.</li> <li><strong>Separation of Concerns</strong>: Design modular systems by clearly defining component responsibilities.</li> <li><strong>Extensibility</strong>: Utilize base classes and virtual methods for adaptable and maintainable code.</li> </ol> <hr/> <h2 id="conclusion">Conclusion</h2> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> and <code class="language-plaintext highlighter-rouge">ParserTarget</code> exemplify PBRT’s thoughtful design, enabling efficient and flexible input processing. By separating tokenization and parsing, these components ensure clarity and adaptability. They serve as excellent case studies for C++ developers seeking to master modern software architecture, particularly in the domain of computer graphics.</p>]]></content><author><name></name></author><category term="C++"/><category term="ModernC++"/><category term="Pbrt"/><summary type="html"><![CDATA[PBRT (Physically Based Rendering Toolkit) is a well-regarded open-source library in computer graphics, renowned for its comprehensive rendering capabilities. Two key components in PBRT’s input pipeline are the Tokenizer and ParserTarget. Together, they enable the parsing and interpretation of scene descriptions. This post delves into their design, functionality, and interplay, showcasing PBRT’s sophisticated input processing mechanism.]]></summary></entry><entry><title type="html">DDG Introduction</title><link href="https://pasu.github.io/blog/2025/DDG_Intro/" rel="alternate" type="text/html" title="DDG Introduction"/><published>2025-01-02T17:27:00+00:00</published><updated>2025-01-02T17:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/DDG_Intro</id><content type="html" xml:base="https://pasu.github.io/blog/2025/DDG_Intro/"><![CDATA[<p>“Life would be easier if the world is continuous.”</p> <h2 id="introduction">Introduction</h2> <p>Have you ever wondered how computers understand shapes and curves? Differential geometry, which traditionally deals with smooth curves and surfaces, might seem far removed from the pixelated and polygonal world of computers. This is where <strong>Discrete Differential Geometry (DDG)</strong> comes in: it bridges the gap between smooth mathematics and computational practicality. Let’s explore what differential geometry and DDG are, their differences, the grand vision of DDG, and an example to make things concrete.</p> <hr/> <h2 id="what-is-differential-geometry">What is Differential Geometry?</h2> <p><strong>Differential geometry</strong> is the mathematical study of smooth shapes like curves and surfaces. It explores how curves, surfaces, and higher-dimensional objects behave locally and globally. Using tools like calculus, it helps answer questions such as:</p> <ul> <li><strong>Curvature:</strong> How much does a curve bend at a specific point?</li> <li><strong>Tangent spaces:</strong> What does a surface look like if you zoom in infinitely close?</li> <li><strong>Manifold</strong>: What are generalized spaces that locally resemble Euclidean spaces?</li> <li><strong>Geodesics:</strong> What is the shortest path between two points on a curved surface?</li> </ul> <p>Imagine drawing a perfect circle on paper and analyzing its smooth properties. Differential geometry provides the theoretical framework for such analysis and has applications in physics, general relativity, and engineering.</p> <hr/> <h2 id="what-is-discrete-differential-geometry">What is Discrete Differential Geometry?</h2> <p><strong>Discrete differential geometry</strong> (DDG) adapts the principles of differential geometry to shapes made of small, discrete parts, like triangles in a mesh or straight edges in a curve. Instead of working with smooth functions and infinitesimal changes, DDG relies on:</p> <ul> <li><strong>Angles between edges</strong> to measure bending.</li> <li><strong>Lengths of edges</strong> to describe shapes.</li> <li><strong>Simple computational rules</strong> that approximate smooth properties.</li> </ul> <p>Think of it like replacing a perfect circle with a polygon made of straight-line segments and then studying the polygon. DDG is particularly useful in computer graphics, simulations, and architectural design.</p> <hr/> <h2 id="the-grand-vision-of-ddg">The Grand Vision of DDG</h2> <p>The goal of DDG is to <strong>translate the tools of differential geometry into a language that computers can use.</strong> This involves creating discrete versions of smooth concepts, enabling practical computation without losing essential geometric properties.</p> <p>This translation involves trade-offs, as no single discrete definition captures all aspects of its smooth counterpart. The approach depends on the specific application: some might prioritize accuracy, while others prioritize simplicity or speed.</p> <hr/> <h2 id="how-ddg-defines-discrete-geometry">How DDG Defines Discrete Geometry</h2> <p>DDG often follows these steps to adapt smooth concepts:</p> <ol> <li><strong>Start with a smooth definition.</strong> For example, curvature in the smooth case measures how much a curve bends.</li> <li><strong>Explore multiple smooth equivalents.</strong> Curvature can be described as the rate of change of the tangent or as the reciprocal of the radius of the osculating circle.</li> <li><strong>Translate these definitions to discrete settings.</strong> For a polygonal curve, curvature could be the turning angle at a vertex or the change in edge lengths when adjusted.</li> <li><strong>Choose the most suitable definition.</strong> The choice depends on what properties matter most for the application, like computational efficiency or fidelity to smooth geometry.</li> </ol> <hr/> <h2 id="an-example-curvature-of-a-curve">An Example: Curvature of a Curve</h2> <ol> <li> <p><strong>Smooth Case:</strong> In differential geometry, the curvature of a smooth curve measures how sharply it bends. For a circle, the curvature is the same everywhere and equals, where is the radius.</p> </li> <li> <p><strong>Discrete Case:</strong> For a polygonal curve made of straight edges:</p> <ul> <li>Curvature at a vertex can be defined as the angle between two connected edges (“<strong>turning angle</strong>”).</li> <li>Alternatively, it could be based on how the total edge length changes when the curve is adjusted (“<strong>length variation</strong>”).</li> </ul> </li> </ol> <p>Both methods are valid but have different strengths. For instance, turning angles are easier to compute, while length variation might better approximate smooth properties.</p> <hr/> <h2 id="why-does-ddg-matter">Why Does DDG Matter?</h2> <p>DDG allows us to:</p> <ul> <li>Simulate physical processes like heat flow or surface deformation.</li> <li>Create detailed 3D models for movies and games.</li> <li>Optimize architectural designs for aesthetics and efficiency.</li> </ul> <p>By bridging smooth mathematics and discrete computation, DDG helps bring complex geometry into the digital age.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>Differential geometry and DDG are like two sides of the same coin. One deals with smooth perfection, and the other brings this perfection into the computational realm. Together, they help us understand and manipulate shapes in both theoretical and practical ways.</p> <p>With its ability to approximate smooth shapes and enable computation, DDG is a powerful tool in fields ranging from graphics to engineering. And while there are trade-offs in translating smooth concepts into discrete ones, DDG’s flexibility and computational efficiency make it invaluable in today’s digital world.</p> <p>If you’ve ever admired a beautifully rendered 3D object in a game or marveled at the flowing curves of modern architecture, chances are you’ve encountered the magic of DDG in action!</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[“Life would be easier if the world is continuous.”]]></summary></entry><entry><title type="html">Learning Modern C++ Through pbrt-v4</title><link href="https://pasu.github.io/blog/2025/Pbrt_Intro/" rel="alternate" type="text/html" title="Learning Modern C++ Through pbrt-v4"/><published>2025-01-02T17:27:00+00:00</published><updated>2025-01-02T17:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/Pbrt_Intro</id><content type="html" xml:base="https://pasu.github.io/blog/2025/Pbrt_Intro/"><![CDATA[<p>pbrt-v4 plays a pivotal role in my research endeavors. Recognizing that my C++ proficiency requires modernization, I view this state-of-the-art open-source project as an ideal platform to enhance my skills in contemporary C++ practices. This series aims to document and share that journey.</p> <h3 id="the-evolution-of-pbrt-v4">The Evolution of pbrt-v4</h3> <p>The journey began with Matt Pharr’s keynote, “Porting pbrt to the GPU While Preserving its Soul,” presented at HPG 2020 [1]. This talk illuminated the integration of modern C++ techniques within pbrt, including advanced memory management, polymorphic memory resources (pmr), and tagged dispatch for efficient polymorphism.</p> <p>Modern C++ represents a paradigm shift from earlier iterations, such as C++98, with consistent updates every three years culminating in C++23. Features like <code class="language-plaintext highlighter-rouge">std::optional</code>, lambdas, <code class="language-plaintext highlighter-rouge">std::move</code>, and <code class="language-plaintext highlighter-rouge">std::thread</code> simplify development and enhance robustness. For inspiration, I recommend the article “Remember the Vase!” by C++ founder Bjarne Stroustrup, who advises: “Work hard on a solid foundation, learn from experience, and don’t scrimp on testing” [2]. Personally, working with the pbrt project offers a hands-on avenue to practice these concepts. Adopting modern C++ isn’t merely about acquiring new skills but also shedding outdated practices, such as over-reliance on <code class="language-plaintext highlighter-rouge">new</code> and raw pointers—a transformation that makes modern C++ feel like “C+” in essence.</p> <p>Moreover, modern C++ is a comprehensive solution for streamlining development and collaboration. It encompasses sophisticated build systems and project layouts (e.g., <strong>CMake</strong>), robust dependency management tools (e.g., <strong>vcpkg</strong> or <strong>Conan</strong>), continuous integration systems (e.g., <strong>GitHub Actions</strong>), and advanced IDEs (e.g., <strong>VS Code</strong>, <strong>Visual Studio</strong>, <strong>CLion</strong>) augmented by powerful AI tools like GitHub Copilot.</p> <h3 id="why-learn-modern-c-through-pbrt-v4">Why Learn Modern C++ Through pbrt-v4?</h3> <h4 id="key-attributes-of-pbrt-v4">Key Attributes of pbrt-v4</h4> <ul> <li>Approximately 72,000 lines of modular, portable C++ code.</li> <li>A design philosophy that balances pedagogical clarity with computational performance.</li> <li>Implementation leveraging <strong>C++17</strong>, with features such as tagged dispatch, polymorphic memory allocation, and GPU-centric paradigms.</li> </ul> <h4 id="rationale-for-employing-pbrt-v4-as-a-learning-platform">Rationale for Employing pbrt-v4 as a Learning Platform</h4> <ol> <li> <p><strong>A Codebase Exemplifying Advanced C++ Constructs</strong></p> <ul> <li>The architecture integrates state-of-the-art programming techniques, including: <ul> <li>Template metaprogramming for abstraction and reusability.</li> <li><code class="language-plaintext highlighter-rouge">std::optional</code> and <code class="language-plaintext highlighter-rouge">std::variant</code> for robust, type-safe data manipulation.</li> <li>Polymorphic memory allocators (<code class="language-plaintext highlighter-rouge">std::pmr</code>) optimized for GPU interoperability, showcasing unified memory allocation strategies.</li> </ul> </li> </ul> </li> <li> <p><strong>Tagged Dispatch as a Paradigm of Polymorphism</strong></p> <ul> <li>Supplanting conventional virtual functions, pbrt-v4 employs tagged dispatch, minimizing runtime overhead while enhancing GPU compatibility. Tagged pointers facilitate efficient, type-safe polymorphism by leveraging compile-time type resolution.</li> </ul> </li> <li> <p><strong>Practical Implementation in High-Performance Contexts</strong></p> <ul> <li>The project exemplifies how modern C++ constructs elevate both maintainability and computational efficiency.</li> <li>Memory allocators (<code class="language-plaintext highlighter-rouge">std::pmr</code>) harmonize resource management across CPU and GPU domains, underscoring their adaptability in complex systems.</li> <li>Tagged dispatch obviates the limitations of virtual functions, presenting a streamlined approach to polymorphism that is both performant and architecturally sound.</li> <li>The design embodies the nuanced decision-making required to develop scalable, high-performance systems.</li> </ul> </li> <li> <p><strong>Integration of Graphics Programming Principles</strong></p> <ul> <li>The framework provides a deep dive into the intricacies of rendering pipelines, mathematical modeling, and parallel computation, all realized through idiomatic C++.</li> </ul> </li> </ol> <h3 id="conclusion">Conclusion</h3> <p>I began learning programming in high school in 2000. As a financially constrained student, I purchased two second-hand books: one on basic programming and another titled C++程序设计 by 谭浩强. My mother, despite our limited means, invested around 8000 RMB in a computer for me. Unfortunately, my first attempt to set up a Turbo C environment resulted in the computer breaking down. Consequently, I couldn’t program on it, but I cherish memories of playing the video game Sword and Fairy (仙剑奇侠传 98) with my sister on that machine.</p> <p>My initial motivation to become a programmer stemmed from a desire to prove that the computer was a worthwhile investment, justifying the significant financial sacrifice my mother made.</p> <p>Proficiency in modern C++ is indispensable for engineers and researchers striving to create scalable, efficient, and robust applications, particularly in performance-critical domains such as computer graphics.</p> <p>Have fun!</p> <h2 id="references">References</h2> <ol> <li>Matt Pharr’s keynote, “<a href="https://highperformancegraphics.org/slides20/wed_pharr.pdf">Porting pbrt to the GPU While Preserving its Soul</a>,” presented at HPG 2020.</li> <li>Bjarne Stroustrup’s article “<a href="https://www.stroustrup.com/P0977-remember-the-vasa.pdf">Remember the Vasa!</a>” highlighting foundational principles in programming and testing.</li> </ol>]]></content><author><name></name></author><category term="C++"/><category term="ModernC++"/><category term="Pbrt"/><summary type="html"><![CDATA[pbrt-v4 plays a pivotal role in my research endeavors. Recognizing that my C++ proficiency requires modernization, I view this state-of-the-art open-source project as an ideal platform to enhance my skills in contemporary C++ practices. This series aims to document and share that journey.]]></summary></entry><entry><title type="html">2025随想</title><link href="https://pasu.github.io/blog/2025/2025_Reflection/" rel="alternate" type="text/html" title="2025随想"/><published>2025-01-02T17:27:00+00:00</published><updated>2025-01-02T17:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/2025_Reflection</id><content type="html" xml:base="https://pasu.github.io/blog/2025/2025_Reflection/"><![CDATA[<p>今天下午工作时，脑海中时不时冒出一些零星的想法，在 Notability 记录下来，形成了如下的一些疑问、思考和心得。</p> <hr/> <h4 id="ai与效率">AI与效率</h4> <p>在过去的一年里，AI 对于 Researcher 和 Engineer 的影响可谓巨大，既是强有力的支持者，也潜藏着“自掘坟墓”的风险。</p> <p>首先，我个人非常喜欢用 ChatGPT 提问，比如探讨“世界是否连续”、用数学理解“人的感情”，甚至从 CNN 的过拟合技术联想到如何解决社会的内卷问题。有一次，我问 ChatGPT：“如果它来做我目前的全局光照项目，会不会比我做得更好？”它给出了否定的答案，多少让我松了口气。在内容创作方面，Canva 和 DALL-E 表现得非常高效，例如我撰写的 3D GIS 系列的 logo，就是通过 DALL-E 生成的。此外，ChatGPT 的语音功能也是一个很棒的英语口语练习工具，闲聊时，和机器聊天也不失为一种乐趣。</p> <p>其次，我试用了 Github Copilot，尽管并未感到惊艳，但它确实是个实用的助手，尤其在基础算法支持上表现出色。如果未来能结合 VA 或 Resharper 等工具的功能，提供代码逻辑分析或性能优化建议，那它将成为编程过程中不可或缺的工具。我认为每个人都应该试用一下，至少可以评估自己的实际能力水平。与此同时，AI 技术对教学也带来了挑战。例如，学生如果使用 Copilot 生成代码完成作业，这是否算作一种“作弊”？这个问题值得深入思考。</p> <h4 id="内容音乐与情感">内容，音乐与情感</h4> <p>有时候在忙碌中，脑海会突然涌现一些难以言喻的感触，那些无法对外人倾诉的无奈，却常能在一首歌中找到共鸣。我一直觉得，这是一种时域、空域与频域的映射。人类情感复杂多样，但若从频域分析，或许只剩下有限的特征值，例如爱恨情仇、喜怒哀乐。而音乐的不同风格，则恰如其分地映射到这些特征中，实现了一种情感与声音的转换。</p> <p>这让我联想到认知的多维性。复杂问题往往是多维的，而高维更令人望而生畏。例如《三体》中经典的“降维打击”——“杀死你，与你无关”或二向箔的攻击。当我们面对复杂问题时，可以选择升维来实现统一的表达，比如 InstanNGP；也可以选择降维来获得近似解法，例如通过投影。升维让我们清晰地描述问题，却可能没有答案；降维则简化了问题，但答案未必完美。此事古难全，仿佛冥冥之中早已注定。</p> <p>于我而言，所谓的答案或许并不重要，它只是面向未来的一个过程。我们能做的，是像《盗梦空间》中的那句台词一样：“Go deep enough.”。</p> <h4 id="人民与公民">人民与公民</h4> <p>2024年是大选年，心中有许多难以言表的感想。最近看了《再会长江》和《逆行人生》，深切希望我国最贫困的群体能过得更好，也期盼每一位公民能够更加深入地理解自身的权利与责任。我坚信中华文化是无价的，中国有着众多杰出的人才，只要赋予更多的自由，必定能激发出无尽的创造力与辉煌。</p> <h4 id="最好与最坏">最好与最坏</h4> <p>经典段子之今年可能会是过去十年里最差的一年，但却是未来十年里最好的一年。其实，在一个全球摆烂的年代，放低自己的期望，事情就变简单了：只需要做的比别人好就足够了。而我们有两个无与伦比的优势，在内卷上，我们不输任何人，除了卷积（AI），另一方面，只要我们不承认自己差，就能立于不败之地，这是很实用的一招，保证了我们的成果不会被资本收割，这就是中国特色之厉害了，我的国。</p> <p>我也幻想过，如果穿越会十年前或二十年前，会有遍地的机会，但这个前提是保持现有的知识水平，如果穿越回两千年前的话，那还得熟读唐诗宋词，最好还能自带一个成长系统来辅助，其实也不容易。当下，因为读博，科研占了太多的时间，有很多想做而没有精力去做的事情，比如：</p> <ul> <li><strong>AI与Neural Rendering</strong>：主要因为自己效率低，没时间了解这些领域的内容，比如3D重建（3D Reconstruction）、扩散模型（Diffusion model）和大语言模型（LLM）的知识储备。</li> <li><strong>基础知识</strong>：数学、物理以及优化方面。</li> <li><strong>生产力工具</strong>：开发一两个能提高效率的工具，并结合AI和数据的解决方案。对我而言，AI并不是单纯的技术，而是产品，需要能实际落地，解决问题。</li> <li><strong>博客</strong>：希望能有足够的时间写自己喜欢的内容。目前保障我持续高效写作的最低基础是每月150元的收入，同时也在思考如何将工作与写作高效结合。</li> <li><strong>阅读</strong>：非技术类方面，想读三本书：《Other Rivers》，《A Brief History of Intelligence》和《A Biography of the Pixel》。</li> <li><strong>工作与生活平衡</strong>：希望能有时间旅行、跑步及追求其他爱好，并投入更多时间到孩子的教育中。</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025_Reflection-480.webp 480w,/assets/img/2025_Reflection-800.webp 800w,/assets/img/2025_Reflection-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025_Reflection.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>这些是今天随想的一些内容，如果是一幅画的话，就是如上，如果是一首歌的话，就是爱情的模样。</p>]]></content><author><name></name></author><category term="随想"/><category term="随想"/><summary type="html"><![CDATA[今天下午工作时，脑海中时不时冒出一些零星的想法，在 Notability 记录下来，形成了如下的一些疑问、思考和心得。]]></summary></entry><entry><title type="html">3D GIS是什么</title><link href="https://pasu.github.io/blog/2024/3DGISIntro/" rel="alternate" type="text/html" title="3D GIS是什么"/><published>2024-04-26T23:01:00+00:00</published><updated>2024-04-26T23:01:00+00:00</updated><id>https://pasu.github.io/blog/2024/3DGISIntro</id><content type="html" xml:base="https://pasu.github.io/blog/2024/3DGISIntro/"><![CDATA[<blockquote> <p>A geographic information system (GIS) is a system that creates, manages, analyzes, and maps all types of data. GIS connects data to a map, integrating location data (where things are) with all types of descriptive information (what things are like there). This provides a foundation for mapping and analysis that is used in science and almost every industry. GIS helps users understand patterns, relationships, and geographic context. The benefits include improved communication and efficiency as well as better management and decision making. （直译）地理信息系统 (GIS) 是创建、管理、分析和绘制所有类型数据的系统。 GIS 将数据连接到地图，将位置数据（事物在哪里）与所有类型的描述性信息（事物在哪里）集成。这为科学和几乎每个行业中使用的绘图和分析奠定了基础。 GIS 帮助用户理解模式、关系和地理背景。好处包括改善沟通和效率以及更好的管理和决策。 —Esri</p> </blockquote> <p>GIS包括地理信息（Geographic，如地球表面的特征和位置）和信息系统的技术（information system, 计算机软件/硬件/数据库），用于收集、存储、处理、分析和可视化地理空间数据。3D技术相较于二维，增加了一个维度，为我们提供了更加真实或新颖的方式来理解世界的空间信息。</p> <p>从数学的角度来看，从3D到2D是通过投影来实现降维的过程。投影的本质是在低维空间找到高维数据的最优近似解。例如，将三维地球投影到二维地图上时，不同的投影方法可以保持面积、距离或角度不变，但无法同时满足这三个条件。而从2D到3D则是通过升维来实现数学表达的统一。例如，通过增加一个维度，以4*4矩阵来表达三维空间的变换（如平移、旋转、缩放）。</p> <p>2D的优势也正是3D的劣势所在：</p> <ul> <li>易于传播：成本低，可利用纸质地图等丰富的传播媒介，便于分享和交流。</li> <li>特征突出：通过降维保存重要特征，减少冗余信息，使得信息更易于理解和使用，例如二维导航可以提供实时信息和准确的决策支持。</li> <li>生理局限：人类大脑对于高维空间的理解能力有限，较难感知和处理超过三维以上的空间信息，例如前庭系统导致VR下的不舒适。</li> </ul> <p>毕竟我们所处的物理空间是三维的，因此3D的优势在于能够真实地表达地理信息，实现对空间的完整呈现。随着技术的不断发展，3D的劣势也在不断地得到改善。个人认为，3D GIS存在主要价值的三个方面是：</p> <ul> <li>Modelling the world</li> <li>Realistic and immersive experience</li> <li>Spatial Analysis</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/DTMs-480.webp 480w,/assets/img/3dgis/DTMs-800.webp 800w,/assets/img/3dgis/DTMs-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/DTMs.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> 从采集开始，数据建模涵盖了不同维度下的需求：地形（2.5D建模）、三维模型（2.75D建模），以及提取模型特征和属性（3D建模），实现了从2D到3D的数据建模升级。 </div> <p>如上图所示，整个建模过程中都离不开计算机图形学和视觉等技术与GIS的结合。在不同场景下，数据格式（如Voxel、Mesh、Point Cloud）和规范（如CityJson、BIM）等内容推动着GIS生态的完善，例如通过开源、OGC以及ISO 191XX系列等地理信息标准。毫无疑问，GIS的核心就是数据建模。</p> <p>GIS数据的可视化技术与图形学密切相关，通过逼真的渲染技术展现复杂的地理空间数据。借助物理模型模拟天气环境（如河流等），利用XR技术提供更沉浸式的体验，三维空间下高效的人机交互设计来最大化挖掘GIS数据的价值。</p> <p>最后，3D GIS可以提供更准确的空间分析，例如日照分析，可视域分析和天际线分析。通过可视化的结果展示，能够为决策提供更全面的分析支持。</p> <p>在不同领域中，3D GIS的这些价值也有着广泛的现实应用，并持续深入。</p> <p>在大众消费领域，Google利用Earth和Maps实现了“通过地理整理全世界的信息”的愿景。通过街景和视觉技术，他们注释了整个地球，实现了“让物理世界可被搜索”的目标。近些年，他们还陆续提出了Big Query和Immersive View等空间分析和可视化的优化方案。<a href="https://mp.weixin.qq.com/s/tn71F425_KvmiuJRslbHBQ">阅读更多</a></p> <p>在企业服务领域，SuperMap（我的前公司）也提供了全面的3D GIS技术解决方案。产品体系涵盖了从三维数据的优化与管理，到海量数据的多端展现和空间分析。这些解决方案在政务、交通、城市等多个行业都得到了广泛的应用。</p> <p>在开源生态中，Cesium提供了全球三维数据资产，并积极地将其3D GIS能力与各个生态系统（如UE/Unity等）对接。在研究领域，metaverse正在构建物理世界和虚拟世界之间的桥梁，推动了真实世界数据建模的数字化和虚拟化进程。智慧城市利用3D技术提高对城市的理解，实现了大规模城市重建，并应用于自动驾驶的实时3D传感技术、建筑物和室外环境的3D表示，以及新气候和能源模拟的智慧城市创新和实验。</p> <p>本文是个人对3D GIS的理解：2D和3D的区别，以及3D GIS的主要价值和不同领域的应用场景。3D GIS的诸多方面可以让这个世界变得更好。</p> <p>只是，这个世界会好吗？</p> <p>我不是很确定。</p>]]></content><author><name></name></author><category term="3DGIS"/><category term="3D"/><category term="GIS"/><category term="简介"/><summary type="html"><![CDATA[A geographic information system (GIS) is a system that creates, manages, analyzes, and maps all types of data. GIS connects data to a map, integrating location data (where things are) with all types of descriptive information (what things are like there). This provides a foundation for mapping and analysis that is used in science and almost every industry. GIS helps users understand patterns, relationships, and geographic context. The benefits include improved communication and efficiency as well as better management and decision making. （直译）地理信息系统 (GIS) 是创建、管理、分析和绘制所有类型数据的系统。 GIS 将数据连接到地图，将位置数据（事物在哪里）与所有类型的描述性信息（事物在哪里）集成。这为科学和几乎每个行业中使用的绘图和分析奠定了基础。 GIS 帮助用户理解模式、关系和地理背景。好处包括改善沟通和效率以及更好的管理和决策。 —Esri]]></summary></entry><entry><title type="html">3D GIS入门指南</title><link href="https://pasu.github.io/blog/2024/3DGISLearning/" rel="alternate" type="text/html" title="3D GIS入门指南"/><published>2024-04-21T11:01:00+00:00</published><updated>2024-04-21T11:01:00+00:00</updated><id>https://pasu.github.io/blog/2024/3DGISLearning</id><content type="html" xml:base="https://pasu.github.io/blog/2024/3DGISLearning/"><![CDATA[<p>3D GIS，顾名思义，要求具备一定的CG（计算机图形学）知识，包括几何学、渲染和模拟等物理建模内容。GIS则涉及地理信息领域，如地形、建筑物和天气等地球尺度下的数据。因此，3D GIS的核心是对物理世界的建模。从开发角度来看，需要具备基本的编程能力，如C++、JS（WebGL/WebGPU）、Shader编程以及性能优化（CPU/GPU）。而3D GIS的研发人员也需要掌握以上三个领域的知识。</p> <p>学习3D GIS存在两个主要挑战：一是知识点繁多且相互交错，难以建立扎实的基础和知识体系；二是从业人员大多来自Web GIS背景，对于C++相关技术如GL和Shader的掌握参差不齐。这些因素使得3D GIS容易上手却难以精通。</p> <p>首先，掌握OpenGL是基本功，<a href="https://learnopengl.com/">Learn OpenGL</a>是一个不错的教程。如果学习OpenGL还有难度，可以先从WebGL入门，比如《WebGL编程指南》，之后再开始OpenGL的学习，图形学比较感兴趣的话，结合看看<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES 101:现代计算机图形学入门</a>。OpenGL/WebGL的优点是学习资料丰富，缺点是属于比较成熟或过时的技术，现在学习有点鸡肋。如果你工作中并不需要使用它们，那么Cuda/Vulkan/DX/WebGPU也是可以考虑的替代方案。目的是掌握基本的编程能力和图形学的基本概念。</p> <p>其次，在这个基础上，需要掌握基本的GIS知识。通常需要了解构建一个地球模型的基本概念。个人觉得通过<a href="https://www.cnblogs.com/fuckgiser/p/5706842.html">Cesium教程</a>以及学习《3D Engine Design for Virtual Globes》是一个不错的方式。Cesium的代码开源，结合Virtual Globes以及对应的源码，目标是掌握构建一个地球模型的基本概念，以及如何应用GL技术来实现该地球模型。</p> <p>最后，拥有这些基础并不意味着我们已经建立了坚实的根基。实际情况往往是在工作推动下，我们解决问题的一知半解。这些问题可能涉及到我们对数学物理等理论知识的欠缺，或者是对算法或开源库的不了解。这些问题是很好的试金石，我们才能发现自己知识体系中的盲区，并有针对性地完善自己。在这个过程中，我们将接触到许多优秀的技术文章、产品和专家，了解他们的学习和思考方式，以及他们关注的问题和前沿技术。这将拓宽我们的认知，调整我们的技术发展方向，比如游戏引擎或AI等相关技术。我们的目标是实现工作和学习的双赢，营造一个良好的学习氛围和环境，持续推动个人的提升。</p> <p>另外，团队成员之间的交流也是必不可少的。在我的学习过程中，我从许多人那里得到了指导和帮助。我个人认为定期的技术交流是值得投入的事情。可以分享自己在工作中解决的问题，也可以分享自己对感兴趣的知识点的理解，通过讲座或讨论会的形式。</p> <p>以上是我个人总结的3D GIS入门简要指南，学少而精，思活而辩。3D GIS行业的发展也离不开每一位从业者的努力。</p>]]></content><author><name></name></author><category term="3DGIS"/><category term="3D"/><category term="GIS"/><category term="入门"/><summary type="html"><![CDATA[3D GIS，顾名思义，要求具备一定的CG（计算机图形学）知识，包括几何学、渲染和模拟等物理建模内容。GIS则涉及地理信息领域，如地形、建筑物和天气等地球尺度下的数据。因此，3D GIS的核心是对物理世界的建模。从开发角度来看，需要具备基本的编程能力，如C++、JS（WebGL/WebGPU）、Shader编程以及性能优化（CPU/GPU）。而3D GIS的研发人员也需要掌握以上三个领域的知识。]]></summary></entry></feed>
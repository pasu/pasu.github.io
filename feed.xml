<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://pasu.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pasu.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-01-25T22:05:25+00:00</updated><id>https://pasu.github.io/feed.xml</id><title type="html">blank</title><subtitle>Personal website of Peter Lu </subtitle><entry><title type="html">DDG k-Forms</title><link href="https://pasu.github.io/blog/2025/ddg_k_forms/" rel="alternate" type="text/html" title="DDG k-Forms"/><published>2025-01-25T10:27:00+00:00</published><updated>2025-01-25T10:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/ddg_k_forms</id><content type="html" xml:base="https://pasu.github.io/blog/2025/ddg_k_forms/"><![CDATA[<h1 id="k-forms-in-exterior-algebra"><strong>k-Forms in Exterior Algebra</strong></h1> <p>A <strong>k-form</strong> is a fundamental concept in <strong>exterior algebra</strong> that generalizes the notion of measurement—such as length, area, or volume—to \(k\)-dimensional spaces. It is a <strong>fully antisymmetric, multilinear map</strong> used to quantify \(k\)-dimensional “volumes,” distinguishing it from <strong>k-vectors</strong>, which represent those volumes.</p> <p>Here’s a way to think about it:</p> <ul> <li>A <strong>k-vector</strong> describes shapes (e.g., the span of a vector or a geometric region).</li> <li>A <strong>k-form</strong> is the tool used to measure these shapes, just as a ruler measures length or a measuring cup gauges volume.</li> </ul> <hr/> <h2 id="vectors-vs-covectors-the-dual-relationship"><strong>Vectors vs. Covectors: The Dual Relationship</strong></h2> <p>Vectors and covectors have a dual relationship, like counterparts in a measurement system:</p> <ul> <li><strong>Vectors</strong> represent quantities with both direction and magnitude.</li> <li><strong>Covectors</strong> are the “measuring tools” for these vectors and are mathematically dual to them.</li> </ul> <h3 id="dual-space-v"><strong>Dual Space</strong> \(V^*\):</h3> <p>Given a vector space \(V\), its dual space \(V^*\) consists of linear maps \(\alpha: V \to \mathbb{R}\). Its structure mirrors \(V\):</p> <ol> <li><strong>Addition</strong>: \((\alpha + \beta)(v) = \alpha(v) + \beta(v)\)</li> <li><strong>Scalar Multiplication</strong>: \((c\alpha)(v) = c \cdot \alpha(v)\)</li> </ol> <h3 id="flat-and-sharp-operators-bridging-vectors-and-covectors"><strong>Flat and Sharp Operators: Bridging Vectors and Covectors</strong></h3> <p>In spaces like \(\mathbb{R}^n\), <strong>flat (\(\flat\))</strong> and <strong>sharp (\(\sharp\))</strong> operators convert between vectors and covectors using the metric tensor \(g\).</p> <ol> <li> <p><strong>Flat (\(\flat\))</strong>: Turns a vector \(v\) into a covector \(v^\flat\): \(v^\flat(w) = g(v, w),\) where \(g(v, w)\) is the inner product.</p> </li> <li> <p><strong>Sharp (\(\sharp\))</strong>: Maps a covector back to a vector \(\alpha^\sharp\): \(g(\alpha^\sharp, w) = \alpha(w).\)</p> </li> </ol> <h3 id="example-working-in-mathbbr2"><strong>Example</strong>: Working in \(\mathbb{R}^2\)</h3> <p>Let the metric tensor \(g = \begin{bmatrix} 2 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}\) and vector \(v = \begin{bmatrix} 3 \\ 4 \end{bmatrix}\).</p> <h4 id="applying-flat"><strong>Applying \(\flat\):</strong></h4> <p>The covector \(v^\flat = g v\): \(v^\flat = \begin{bmatrix} 6 \\ 4 \end{bmatrix}.\)</p> <h4 id="applying-sharp"><strong>Applying \(\sharp\):</strong></h4> <p>The vector \(\alpha^\sharp = g^{-1} \alpha\): \(\alpha^\sharp = \begin{bmatrix} 3 \\ 4 \end{bmatrix},\) retrieving the original vector \(v\).</p> <h4 id="inner-product-verification"><strong>Inner Product Verification</strong></h4> <p>Verify the consistency of the inner product:</p> <ol> <li> <p>Compute directly with \(g\): Let \(u = \begin{bmatrix} 1 \\ 2 \end{bmatrix}\), then: \(\langle v, u \rangle = v^T g u = \begin{bmatrix} 3 &amp; 4 \end{bmatrix} \begin{bmatrix} 2 &amp; 0 \\ 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 \\ 2 \end{bmatrix} = 10.\)</p> </li> <li> <p>Compute using \(v^\flat\): \(v^\flat(u) = \begin{bmatrix} 6 &amp; 4 \end{bmatrix} \begin{bmatrix} 1 \\ 2 \end{bmatrix} = 6 \cdot 1 + 4 \cdot 2 = 10.\)</p> </li> </ol> <p>Both methods agree, confirming the consistency of the operation. Applying the flat of a vector is the same as taking the inner product; taking the inner product with the sharp is the same as applying the original covector.</p> <hr/> <h2 id="k-forms"><strong>k-Forms</strong></h2> <table> <thead> <tr> <th> </th> <th><strong>Primal</strong></th> <th><strong>Dual</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Linear Algebra</strong></td> <td>Vectors</td> <td>Covectors</td> </tr> <tr> <td><strong>Exterior Algebra</strong></td> <td>\(k\)-vectors</td> <td>\(k\)-forms</td> </tr> </tbody> </table> <p>We can now define <strong>covectors</strong>, which are linear maps from vectors to scalars. <strong>Exterior algebra</strong> allows us to construct \(k\)-vectors from vectors, and by combining these ideas, we can build an exterior algebra of covectors, referred to as \(k\)-forms, which are multilinear maps.</p> <p>A <strong>1-form</strong> can be thought of as a covector \(\alpha\) ‘measuring’ a vector \(u\). This is expressed as a function application \(\alpha(u)\). In component form, this is written as: \(\alpha(\mu) := \sum_i \alpha_i \mu^i,\) where \(\alpha_i\) are the components of the covector and \(\mu^i\) are the components of the vector.</p> <p>Similarly, we can extend this concept to 2-forms as a projected area and 3-forms as a projected volume.</p> <p>We compute the projected area of a parallelogram defined by two vectors \(u\) and \(v\) onto a plane using the 2-form \((\alpha \wedge \beta)(u, v) := \alpha(u)\beta(v) - \alpha(v)\beta(u)\), where \(\alpha\) and \(\beta\) are covectors.</p> <p>To compute the <strong>projected volume</strong> of a parallelepiped defined by three vectors \(u\), \(v\), and \(w\) onto the space spanned by three covectors \(\alpha\), \(\beta\), and \(\gamma\), we use a 3-form \(\alpha \wedge \beta \wedge \gamma\), defined as: \((\alpha \wedge \beta \wedge \gamma)(u, v, w) = \text{det} \begin{bmatrix} \alpha(u) &amp; \alpha(v) &amp; \alpha(w) \\ \beta(u) &amp; \beta(v) &amp; \beta(w) \\ \gamma(u) &amp; \gamma(v) &amp; \gamma(w) \end{bmatrix}.\)</p> <p>The determinant here captures the signed volume of the parallelepiped after being ‘measured’ by the covectors \(\alpha\), \(\beta\), and \(\gamma\).</p> <h3 id="conceptual-evaluation-of-k-forms"><strong>Conceptual Evaluation of \(k\)-forms</strong></h3> <p>Evaluating a \(k\)-form on \(k\) vectors using a determinant is given by:</p> \[(\alpha_1 \wedge \alpha_2 \wedge \cdots \wedge \alpha_k)(u_1, u_2, \dots, u_k) := \text{det} \begin{bmatrix} \alpha_1(u_1) &amp; \alpha_1(u_2) &amp; \cdots &amp; \alpha_1(u_k) \\ \alpha_2(u_1) &amp; \alpha_2(u_2) &amp; \cdots &amp; \alpha_2(u_k) \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \alpha_k(u_1) &amp; \alpha_k(u_2) &amp; \cdots &amp; \alpha_k(u_k) \end{bmatrix}.\] <p>This formulation enables the computation of volume-like quantities in higher dimensions using determinants, thus establishing a clear connection between algebraic structures and geometry.</p> <h3 id="antisymmetry-of-k-forms"><strong>Antisymmetry of \(k\)-forms</strong></h3> <p>One key property of \(k\)-forms is their <strong>antisymmetry</strong>. This means that swapping any two arguments (whether they are vectors or covectors) reverses the sign of the result. For example, if we exchange two vectors \(u_i\) and \(u_j\) in the evaluation of a \(k\)-form \(\alpha_1 \wedge \alpha_2 \wedge \cdots \wedge \alpha_k\), the value of the form changes its sign:</p> \[(\alpha_1 \wedge \cdots \wedge \alpha_k)(u_1, \dots, u_i, \dots, u_j, \dots, u_k) = - (\alpha_1 \wedge \cdots \wedge \alpha_k)(u_1, \dots, u_j, \dots, u_i, \dots, u_k).\] <p>This property is crucial because it reflects the fact that swapping vectors or covectors reverses the orientation of the parallelepiped (or higher-dimensional object) spanned by the vectors. If any two vectors are linearly dependent, the result is zero, as the volume collapses to zero.</p> <hr/> <h2 id="dual-basis">Dual Basis</h2> <p>In differential geometry and exterior algebra, the <strong>dual basis</strong> \(e^1, e^2, \dots, e^n\) provides a natural framework for representing covectors (or 1-forms) in terms of their components. A covector \(\alpha\) can be expressed as:</p> \[\alpha = \alpha_1 e^1 + \alpha_2 e^2 + \cdots + \alpha_n e^n,\] <p>where \(\alpha_1, \alpha_2, \dots, \alpha_n\) are the components of \(\alpha\), and \(e^1, e^2, \dots, e^n\) are the elements of the dual basis. The dual basis is defined such that:</p> \[e^i(e_j) = \delta^i_j,\] <p>where \(\delta^i_j\) is the <strong>Kronecker delta</strong> (\(\delta^i_j = 1\) if \(i = j\), and \(0\) otherwise). This definition establishes the dual relationship between the basis \(\{e_1, e_2, \dots, e_n\}\) and its dual \(\{e^1, e^2, \dots, e^n\}\).</p> <p>The dual basis plays a crucial role in translating geometric objects into algebraic representations. For instance, it allows the components of a covector \(\alpha\) to be easily computed by evaluating \(\alpha(e_j) = \alpha_j\). This forms the foundation for manipulating geometric and algebraic structures within vector spaces.</p> <p>Moreover, the dual basis serves as a bridge between vectors and covectors, enabling operations such as contraction, wedge products, and the transition between the primal and dual spaces. It is indispensable for understanding the interaction between geometry and algebra.</p> <h2 id="example-computing-alpha-wedge-betau-v">Example: Computing \((\alpha \wedge \beta)(u, v)\)</h2> <p>Let’s calculate \((\alpha \wedge \beta)(u, v)\) step by step using the following example:</p> <h3 id="given">Given:</h3> <ul> <li>\(u = 2e_1 + 2e_2\),</li> <li>\(v = -2e_1 + 2e_2\),</li> <li>\(\alpha = e^1 + 3e^2\),</li> <li>\(\beta = 2e^1 + e^2\).</li> </ul> <p>The wedge product \(\alpha \wedge \beta\) applied to \(u\) and \(v\) is defined as:</p> \[(\alpha \wedge \beta)(u, v) = \alpha(u) \beta(v) - \alpha(v) \beta(u).\] <h3 id="step-by-step-computation">Step-by-Step Computation:</h3> <ol> <li><strong>Compute \(\alpha(u)\):</strong></li> </ol> \[\alpha(u) = (e^1 + 3e^2)(2e_1 + 2e_2) = 2 \cdot 1 + 2 \cdot 3 = 2 + 6 = 8.\] <ol> <li><strong>Compute \(\beta(v)\):</strong></li> </ol> \[\beta(v) = (2e^1 + e^2)(-2e_1 + 2e_2) = 2 \cdot (-2) + 1 \cdot 2 = -4 + 2 = -2.\] <ol> <li><strong>Compute \(\alpha(v)\):</strong></li> </ol> \[\alpha(v) = (e^1 + 3e^2)(-2e_1 + 2e_2) = 1 \cdot (-2) + 3 \cdot 2 = -2 + 6 = 4.\] <ol> <li><strong>Compute \(\beta(u)\):</strong></li> </ol> \[\beta(u) = (2e^1 + e^2)(2e_1 + 2e_2) = 2 \cdot 2 + 1 \cdot 2 = 4 + 2 = 6.\] <h3 id="final-calculation">Final Calculation:</h3> \[(\alpha \wedge \beta)(u, v) = \alpha(u) \beta(v) - \alpha(v) \beta(u),\] \[(\alpha \wedge \beta)(u, v) = 8 \cdot (-2) - 4 \cdot 6 = -16 - 24 = -40.\] <h3 id="result">Result:</h3> \[(\alpha \wedge \beta)(u, v) = -40.\] <p>This result represents the signed area spanned by \(u\) and \(v\), measured by \(\alpha\) and \(\beta\). The negative sign reflects the orientation with respect to the chosen basis.</p> <h3 id="einstein-summation">Einstein Summation</h3> <p>Einstein summation notation simplifies expressions involving repeated indices by implicitly summing over them, making equations more compact and elegant. The convention is as follows: whenever an index appears twice in a term—once as an “up” (contravariant) index and once as a “down” (covariant) index—it is understood to be summed over all possible values of the index.</p> <p>For example, consider a 2-form \(\alpha \wedge \beta\) acting on two vectors \(u\) and \(v\). In Einstein summation notation, this can be expressed as:</p> \[(\alpha \wedge \beta)(u, v) = \alpha_i \beta_j u^i v^j.\] <p>Here:</p> <ul> <li>\(\alpha_i\) and \(\beta_j\) are the components of the covectors \(\alpha\) and \(\beta\),</li> <li>\(u^i\) and \(v^j\) are the components of the vectors \(u\) and \(v\),</li> <li>The repeated indices \(i\) and \(j\) indicate implicit summation over their possible values.</li> </ul> <p>Expanding this for specific components, it means:</p> \[(\alpha \wedge \beta)(u, v) = \sum_{i,j} \alpha_i \beta_j u^i v^j.\] <p>This shorthand notation significantly reduces complexity when working with high-dimensional spaces or numerous terms.</p> <p>Albert Einstein, who introduced this idea, famously remarked:<br/> <strong>“If an index occurs twice in a term, we always perform summation over this index.”</strong></p> <p>This elegant principle has since become a cornerstone of tensor calculus, used extensively in fields like differential geometry, general relativity, and theoretical physics.</p> <p>The power of Einstein summation doesn’t stop here—it can be extended to tensor diagrams, offering a visual and accessible approach to tensor manipulations. Richard Feynman humorously envisioned the impact of such streamlined representations:<br/> <strong>“Wouldn’t it be funny if this turns out to be useful, and the <em>Physical Review</em> would be all full of these funny-looking pictures?”</strong></p> <p>Indeed, these tools have proven invaluable, becoming essential in the study of mathematical and physical systems.</p> <h2 id="sharp--and-flat-flat-operators">Sharp (\(\#\)) and Flat (\(\flat\)) Operators</h2> <p>The <strong>sharp</strong> and <strong>flat</strong> operators enable us to transition between vectors and covectors by raising or lowering indices using the <strong>metric tensor</strong>.</p> <ol> <li><strong>Flat (\(\flat\))</strong>: Converts a vector \(v^i\) into a covector \(v_i\) using the metric \(g_{ij}\):</li> </ol> \[v_i = g_{ij} v^j.\] <ol> <li><strong>Sharp (\(\#\))</strong>: Converts a covector \(\alpha_i\) into a vector \(\alpha^i\) using the inverse metric \(g^{ij}\):</li> </ol> \[\alpha^i = g^{ij} \alpha_j.\] <p>These operations depend on the geometry of the space, as encoded by the metric, and they provide a fundamental link between the primal and dual spaces, analogous to the interplay of sharp and flat notes in music.</p> <p>In conclusion, <strong>k-forms</strong> in exterior algebra provide a powerful tool for measuring geometric quantities like area, volume, and higher-dimensional analogs. By using <strong>covectors</strong> to define <strong>k-forms</strong>, we bridge the gap between algebraic structures and geometry, enabling us to quantify \(k\)-dimensional volumes. The <strong>antisymmetry</strong> of \(k\)-forms plays a vital role in capturing orientation and ensuring that the measurement reflects the geometric structure. Understanding the interplay between <strong>vectors</strong>, <strong>covectors</strong>, and the <strong>flat</strong> and <strong>sharp</strong> operators further deepens our grasp of the dual nature of these objects, reinforcing the relationship between geometry and linear algebra.</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[k-Forms in Exterior Algebra]]></summary></entry><entry><title type="html">DDG Exterior Algebra</title><link href="https://pasu.github.io/blog/2025/ddg_exterior/" rel="alternate" type="text/html" title="DDG Exterior Algebra"/><published>2025-01-13T10:27:00+00:00</published><updated>2025-01-13T10:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/ddg_exterior</id><content type="html" xml:base="https://pasu.github.io/blog/2025/ddg_exterior/"><![CDATA[<h3 id="exterior-algebra-a-framework-for-geometric-computations"><strong>Exterior Algebra: A Framework for Geometric Computations</strong></h3> <p>Exterior algebra offers a robust mathematical framework for understanding and manipulating geometric objects such as volumes, areas, and orientations in higher-dimensional spaces. This post delves into three key concepts: the <strong>wedge product</strong>, the <strong>Hodge star</strong>, and <strong>coordinate representation</strong>, exploring how they allow us to express and compute signed volumes and their orthogonal complements.</p> <hr/> <h3 id="1-the-wedge-product-building-oriented-k-vectors"><strong>1. The Wedge Product: Building Oriented k-Vectors</strong></h3> <p>The <strong>wedge product</strong> is the cornerstone of exterior algebra, enabling the construction of higher-dimensional geometric objects by combining vectors.</p> <h4 id="span"><strong>Span</strong></h4> <p>The concept of span is fundamental to understanding the wedge product. The <strong>span</strong> of a set of vectors is the collection of all possible linear combinations of those vectors:</p> \[\text{span}\{\mathbf{v}_1, \mathbf{v}_2, \dots, \mathbf{v}_k\} = \{a_1\mathbf{v}_1 + a_2\mathbf{v}_2 + \dots + a_k\mathbf{v}_k \mid a_i \in \mathbb{R}\}.\] <p>Geometrically, the span defines the subspace generated by the vectors. For instance:</p> <ul> <li>The span of one vector is a line.</li> <li>The span of two linearly independent vectors is a plane.</li> </ul> <h4 id="definition"><strong>Definition</strong></h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/5_exterior_wedge-480.webp 480w,/assets/img/DDG/5_exterior_wedge-800.webp 800w,/assets/img/DDG/5_exterior_wedge-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/5_exterior_wedge.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The wedge product \(\mathbf{u} \wedge \mathbf{v}\) represents the signed and oriented area of the parallelogram spanned by \(\mathbf{u}\) and \(\mathbf{v}\). More generally, the wedge product of \(k\) vectors spans a \(k\)-dimensional volume.</p> <h4 id="antisymmetry"><strong>Antisymmetry</strong></h4> <ul> <li>Swapping the order of vectors reverses the orientation: \(\mathbf{u} \wedge \mathbf{v} = -\mathbf{v} \wedge \mathbf{u}\).</li> <li>If two vectors are parallel, their wedge product is zero because they cannot span a higher-dimensional volume.</li> </ul> <h4 id="k-vectors"><strong>k-Vectors</strong></h4> <p>A <strong>k-vector</strong> is the wedge product of \(k\) vectors, representing an oriented geometric quantity. Examples include:</p> <ul> <li><strong>0-vectors</strong>, which are scalars.</li> <li><strong>1-vectors</strong>, which are ordinary vectors.</li> <li><strong>2-vectors</strong>, which represent oriented areas.</li> <li><strong>3-vectors</strong>, which represent oriented volumes.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/5_exterior_k-vectors-480.webp 480w,/assets/img/DDG/5_exterior_k-vectors-800.webp 800w,/assets/img/DDG/5_exterior_k-vectors-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/5_exterior_k-vectors.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="geometric-interpretation"><strong>Geometric Interpretation</strong></h4> <p>The wedge product \(\mathbf{u} \wedge \mathbf{v}\) encodes both the magnitude and orientation of the parallelogram formed by \(\mathbf{u}\) and \(\mathbf{v}\), with the orientation determined by the order of the vectors.</p> <hr/> <h3 id="2-the-hodge-star-orthogonal-complements-and-duality"><strong>2. The Hodge Star: Orthogonal Complements and Duality</strong></h3> <p>The <strong>Hodge star</strong> operation complements the wedge product by mapping a k-vector to its orthogonal complement in the vector space.</p> <h4 id="orthogonal-complement"><strong>Orthogonal Complement</strong></h4> <p>The <strong>orthogonal complement</strong> of a subspace \(W\) in a vector space \(V\) consists of all vectors in \(V\) that are orthogonal to every vector in \(W\):</p> \[W^\perp = \{\mathbf{v} \in V \mid \langle \mathbf{v}, \mathbf{w} \rangle = 0 \ \text{for all } \mathbf{w} \in W\},\] <p>where \(\langle \cdot, \cdot \rangle\) is the inner product.</p> <p>Geometrically, the orthogonal complement captures what a subspace excludes. For example:</p> <ul> <li>In 3D, the orthogonal complement of a plane is a line perpendicular to it.</li> <li>In 2D, the orthogonal complement of a line is another line perpendicular to it.</li> </ul> <h4 id="the-hodge-star"><strong>The Hodge Star</strong></h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/5_exterior_hodge-480.webp 480w,/assets/img/DDG/5_exterior_hodge-800.webp 800w,/assets/img/DDG/5_exterior_hodge-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/5_exterior_hodge.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The <strong>Hodge star</strong> maps a k-vector to its \((n-k)\)-vector orthogonal complement, where \(n\) is the dimension of the space. This mapping depends on the inner product structure of the space.</p> <h4 id="key-properties"><strong>Key Properties</strong></h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/5_exterior_hodge_star-480.webp 480w,/assets/img/DDG/5_exterior_hodge_star-800.webp 800w,/assets/img/DDG/5_exterior_hodge_star-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/5_exterior_hodge_star.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <ul> <li><strong>Signed Complement</strong>: The Hodge star transforms a k-vector into a complementary volume with its orientation preserved.</li> <li> <p><strong>Double Star</strong>: Applying the Hodge star twice yields a scalar multiple of the original vector:</p> \[\star (\star \mathbf{v}) = (-1)^{k(n-k)} \mathbf{v}.\] </li> </ul> <h4 id="geometric-example"><strong>Geometric Example</strong></h4> <p>In 3D space:</p> <ul> <li>The Hodge star of a 1-vector (line) is a 2-vector (plane orthogonal to the line).</li> <li>The Hodge star of a 2-vector (plane) is a 1-vector (line orthogonal to the plane).</li> </ul> <h4 id="applications"><strong>Applications</strong></h4> <p>The Hodge star connects the wedge product and duality:</p> <ol> <li>Wedge \(k\)-vectors to compute a signed volume.</li> <li>Apply the Hodge star to find its complementary \((n-k)\)-vector.</li> </ol> <p>For example, in 3D, the wedge product \(\mathbf{u} \wedge \mathbf{v}\) spans a plane (2-vector), and the Hodge star transforms it into a vector orthogonal to that plane.</p> <hr/> <h3 id="3-coordinate-representation"><strong>3. Coordinate Representation</strong></h3> <p>Exterior algebra gains its computational power by expressing vectors and their combinations in terms of basis elements. This section examines basis k-vectors and how the Hodge star maps between complementary dimensions, concluding with an example involving the wedge product and area.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/5_exterior_basis-480.webp 480w,/assets/img/DDG/5_exterior_basis-800.webp 800w,/assets/img/DDG/5_exterior_basis-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/5_exterior_basis.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="basis-vectors-and-k-vectors"><strong>Basis Vectors and k-Vectors</strong></h4> <p><strong>Basis 1-Vectors</strong>:</p> <p>In \(\mathbb{R}^n\), the basis 1-vectors \(\{\mathbf{e}\_1, \mathbf{e}\_2, \dots, \mathbf{e}\_n\}\) are standard unit vectors that span the entire space. Any vector \(\mathbf{v}\) can be expressed as:</p> \[\mathbf{v} = v_1 \mathbf{e}_1 + v_2 \mathbf{e}_2 + \dots + v_n \mathbf{e}_n,\] <p>where \(v_i\) are scalar coefficients.</p> <p><strong>Basis 2-Vectors</strong>:</p> <p>A 2-vector is the wedge product of two basis 1-vectors, such as \(\mathbf{e}\_i \wedge \mathbf{e}\_j\) (with \(i &lt; j\)). These represent oriented areas in the planes spanned by the two vectors. For \(\mathbb{R}^3\), there are \(\binom{3}{2} = 3\) basis 2-vectors:</p> \[\{\mathbf{e}_1 \wedge \mathbf{e}_2, \mathbf{e}_1 \wedge \mathbf{e}_3, \mathbf{e}_2 \wedge \mathbf{e}_3\}.\] <p><strong>Basis 3-Vectors</strong>:</p> <p>A 3-vector is the wedge product of three basis 1-vectors, representing oriented volumes. In \(\mathbb{R}^3\), there is only one basis 3-vector (up to scaling):</p> \[\mathbf{e}_1 \wedge \mathbf{e}_2 \wedge \mathbf{e}_3.\] <p><strong>General Basis k-Vectors</strong>:</p> <p>In \(\mathbb{R}^n\), a basis k-vector is the wedge product of \(k\) distinct basis 1-vectors:</p> \[\mathbf{e}_{i_1} \wedge \mathbf{e}_{i_2} \wedge \dots \wedge \mathbf{e}_{i_k}, \quad 1 \leq i_1 &lt; i_2 &lt; \dots &lt; i_k \leq n.\] <p>The total number of basis k-vectors is \(\binom{n}{k}\), the number of ways to choose \(k\) vectors from \(n\).</p> <h4 id="hodge-star-and-basis-k-vectors"><strong>Hodge Star and Basis k-Vectors</strong></h4> <p>The <strong>Hodge star</strong> maps a basis k-vector in \(\mathbb{R}^n\) to its complementary \((n-k)\)-vector. For \(\mathbb{R}^3\):</p> <ul> <li> <p>The Hodge star of a <strong>basis 1-vector</strong> maps it to a basis 2-vector:</p> \[\star \mathbf{e}_1 = \mathbf{e}_2 \wedge \mathbf{e}_3, \quad \star \mathbf{e}_2 = \mathbf{e}_3 \wedge \mathbf{e}_1, \quad \star \mathbf{e}_3 = \mathbf{e}_1 \wedge \mathbf{e}_2.\] </li> <li> <p>The Hodge star of a <strong>basis 2-vector</strong> maps it to a basis 1-vector:</p> \[\star (\mathbf{e}_1 \wedge \mathbf{e}_2) = \mathbf{e}_3, \quad \star (\mathbf{e}_2 \wedge \mathbf{e}_3) = \mathbf{e}_1, \quad \star (\mathbf{e}_3 \wedge \mathbf{e}_1) = \mathbf{e}_2.\] </li> <li> <p>The Hodge star of a <strong>basis 3-vector</strong> maps it to a scalar (0-vector):</p> \[\star (\mathbf{e}_1 \wedge \mathbf{e}_2 \wedge \mathbf{e}_3) = 1.\] </li> </ul> <h4 id="example-wedge-product-and-area"><strong>Example: Wedge Product and Area</strong></h4> <p>To see how the wedge product relates to area, consider two vectors \(\mathbf{u} = u_1 \mathbf{e}\_1 + u_2 \mathbf{e}\_2 + u_3 \mathbf{e}\_3\) and \(\mathbf{v} = v_1 \mathbf{e}\_1 + v_2 \mathbf{e}\_2 + v_3 \mathbf{e}\_3\) in \(\mathbb{R}^3\).</p> <p>The wedge product \(\mathbf{u} \wedge \mathbf{v}\) expands to:</p> \[\mathbf{u} \wedge \mathbf{v} = (u_1 v_2 - u_2 v_1) \mathbf{e}_1 \wedge \mathbf{e}_2 + (u_2 v_3 - u_3 v_2) \mathbf{e}_2 \wedge \mathbf{e}_3 + (u_3 v_1 - u_1 v_3) \mathbf{e}_3 \wedge \mathbf{e}_1.\] <p>The coefficients \(u_i v_j - u_j v_i\) represent the signed areas of the parallelograms projected onto the coordinate planes. The magnitude of \(\mathbf{u} \wedge \mathbf{v}\) gives the parallelogram’s total area, while the orientation is encoded in the basis 2-vectors.</p> <hr/> <p>Exterior algebra provides a systematic and elegant way to describe and compute geometric objects, making it a cornerstone in fields like physics, geometry, and computer graphics.</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[Exterior Algebra: A Framework for Geometric Computations]]></summary></entry><entry><title type="html">Streets.GL Meets OSMBuilding</title><link href="https://pasu.github.io/blog/2025/streets_gl/" rel="alternate" type="text/html" title="Streets.GL Meets OSMBuilding"/><published>2025-01-11T20:27:00+00:00</published><updated>2025-01-11T20:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/streets_gl</id><content type="html" xml:base="https://pasu.github.io/blog/2025/streets_gl/"><![CDATA[<div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/streets_gl-480.webp 480w,/assets/img/3dgis/streets_gl-800.webp 800w,/assets/img/3dgis/streets_gl-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/streets_gl.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Have you ever wondered if you could quickly create a vivid 3D city map on the web using open-source tools? This article introduces two fascinating projects: <strong>Streets.GL</strong> and <strong>OSMBuilding</strong>. Both are based on OpenStreetMap data, transforming abstract map elements into 3D buildings, roads, and trees. <strong>Streets.GL</strong> focuses on advanced rendering effects like dynamic lighting and atmospheric simulation, making it ideal for showcasing detailed 3D map scenes. On the other hand, <strong>OSMBuilding</strong> is more lightweight, designed for simple building visualization and easy integration into various mapping applications. Whether you’re looking to present complex urban landscapes or create quick, interactive maps, these two tools each offer unique advantages.</p> <h1 id="streetsgl">Streets.GL</h1> <p>Last week, my colleague shared a fascinating web application called <a href="https://streets.gl/">Streets.GL</a>. Intrigued by its unique approach, I explored its features despite having limited time. In today’s push for ultra-realistic graphics, we often overlook the costs and practicality. Streets.GL, however, strikes a balance between rendering quality and global 3D building visualization, offering a practical and efficient alternative.</p> <p>Streets.GL is an open-source, web-based 3D map renderer that utilizes OpenStreetMap (OSM) data to create dynamic, interactive visualizations of various geographical features, including buildings, roads, paths, and trees. Developed by StrandedKitty, the project was announced on May 2, 2023. It aims to promote open data while providing the mapping community with a tool for visual map validation.</p> <p>Written in TypeScript, Streets.GL leverages a custom low-level library that wraps the WebGL2 API for rendering. It uses a render graph to manage its rendering pipeline, generating geometry in real time to support complex building shapes, adhering to the Simple 3D Buildings schema. Initially, data was sourced from public Overpass API instances. However, as of June 24, 2023, Streets.GL transitioned to a custom self-hosted vector tileset for improved tile loading speed, reducing strain on public servers. This change introduces a slight lag in map updates as tilesets are refreshed weekly.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/streets_featuers-480.webp 480w,/assets/img/3dgis/streets_featuers-800.webp 800w,/assets/img/3dgis/streets_featuers-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/streets_featuers.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h2 id="key-features">Key Features:</h2> <ul> <li><strong>OSM Features:</strong> Renders map elements such as buildings, roads, and trees accurately.</li> <li><strong>Dynamic Lighting:</strong> Supports configurable times of day to display lighting effects.</li> <li><strong>Global Map Search:</strong> Powered by Nominatim for worldwide location searches.</li> <li><strong>Live Air Traffic:</strong> Displays real-time air traffic data within the map.</li> <li><strong>Terrain with LOD:</strong> Adjusts terrain detail based on zoom level.</li> <li><strong>Advanced Rendering:</strong> Uses deferred shading, Physically Based Rendering (PBR), Temporal Anti-Aliasing (TAA), and effects like ambient occlusion, depth of field, screen-space reflections, and bloom.</li> <li><strong>Atmosphere Rendering:</strong> Provides realistic aerial perspective and atmospheric effects.</li> </ul> <p>Though the project has seen no updates since September 24, 2023, Streets.GL remains a valuable tool for visualizing OSM data in 3D. Users can explore the application live at streets.gl and review its source code on GitHub.</p> <hr/> <h2 id="osmbuilding">OSMBuilding</h2> <p>OSM Buildings is an open-source JavaScript library for visualizing OpenStreetMap (OSM) building geometry in 2D and 3D. It enables developers to add rich, interactive urban landscapes to web maps efficiently.</p> <h3 id="key-features-1">Key Features:</h3> <p><strong>1. Compatibility:</strong></p> <ul> <li><strong>Classic 2.5D Version:</strong> Designed for older hardware, integrates with Leaflet and OpenLayers 2, and supports shadow simulation.</li> <li><strong>Modern 3D Version:</strong> Optimized for modern hardware, manages large datasets, and uses GLMap for rendering and event handling.</li> </ul> <p><strong>2. Customization:</strong></p> <ul> <li>Allows developers to modify attributes like color, height, and roof shape to meet specific project needs.</li> </ul> <p><strong>3. Integration:</strong></p> <ul> <li>Compatible with mapping services, supporting custom map tiles and GeoJSON sources.</li> </ul> <h3 id="pipeline">Pipeline</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/streets_roof_property-480.webp 480w,/assets/img/3dgis/streets_roof_property-800.webp 800w,/assets/img/3dgis/streets_roof_property-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/streets_roof_property.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>OSMBuilding processes GeoJSON data to create triangle meshes for 3D rendering using the following steps:</p> <ol> <li> <p><strong>Load GeoJSON Data:</strong></p> <ul> <li>Iterate through each feature in the <code class="language-plaintext highlighter-rouge">geojson.features</code> array.</li> </ul> </li> <li> <p><strong>Process Each Feature:</strong></p> <ul> <li>Pass each feature into the <code class="language-plaintext highlighter-rouge">triangulate</code> function to generate 3D geometry.</li> </ul> </li> <li> <p><strong>Base Mesh (via <code class="language-plaintext highlighter-rouge">addBuilding</code>):</strong></p> <ul> <li><strong>Convert Geometry:</strong> Transform the feature’s 2D latitude and longitude into local 3D coordinates.</li> <li><strong>Create Base:</strong> Generate a triangle mesh of the building’s ground footprint using a triangulation algorithm like <code class="language-plaintext highlighter-rouge">earcut</code>.</li> <li><strong>Extrude Walls:</strong> Create vertical walls by connecting the base to vertices at the building’s specified height.</li> </ul> </li> <li> <p><strong>Roof Mesh (via <code class="language-plaintext highlighter-rouge">createRoof</code>):</strong></p> <ul> <li><strong>Interpret Roof Properties:</strong> Use attributes like height, shape, and direction to determine roof vertices.</li> <li><strong>Generate Roof Shape:</strong> Apply specific logic based on the roof’s shape (e.g., flat or skillion) to build the triangle mesh.</li> </ul> </li> <li> <p><strong>Combine Geometry:</strong></p> <ul> <li>Consolidate vertices and indices from the base, walls, and roof into a shared geometry buffer.</li> </ul> </li> <li> <p><strong>Render 3D Mesh:</strong></p> <ul> <li>Send the combined triangle mesh to a rendering engine like WebGL or Three.js.</li> </ul> </li> </ol> <h3 id="simple-3d-buildings-schema">Simple 3D Buildings Schema</h3> <p>The <a href="https://wiki.openstreetmap.org/wiki/Simple_3D_Buildings">Simple 3D Buildings</a> schema standardizes 3D attributes in OSM, enhancing building visualization by defining their three-dimensional properties.</p> <h4 id="key-components">Key Components:</h4> <ol> <li> <p><strong>Building Outlines (<code class="language-plaintext highlighter-rouge">building=*</code>):</strong></p> <ul> <li>Represent the building’s footprint.</li> <li>Include attributes like address, name, overall height, and operator.</li> </ul> </li> <li> <p><strong>Building Parts (<code class="language-plaintext highlighter-rouge">building:part=*</code>):</strong></p> <ul> <li>Specify sections of a building with distinct physical characteristics.</li> <li>Support detailed modeling of complex structures.</li> </ul> </li> <li> <p><strong>Height Attributes:</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">height=*</code>: Total height of the building or part.</li> <li><code class="language-plaintext highlighter-rouge">min_height=*</code>: Starting height above the ground.</li> <li><code class="language-plaintext highlighter-rouge">building:levels=*</code>: Number of levels above ground.</li> <li><code class="language-plaintext highlighter-rouge">roof:levels=*</code>: Number of levels within the roof.</li> </ul> </li> <li> <p><strong>Roof Attributes:</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">roof:shape=*</code>: Specifies the roof shape (e.g., flat, gabled).</li> <li><code class="language-plaintext highlighter-rouge">roof:height=*</code>: Vertical height of the roof.</li> <li><code class="language-plaintext highlighter-rouge">roof:material=*</code>: Roof material (e.g., tiles, metal).</li> <li><code class="language-plaintext highlighter-rouge">roof:orientation=*</code>: Orientation, particularly for asymmetrical roofs.</li> </ul> </li> <li> <p><strong>Material and Color Attributes:</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">building:material=*</code> and <code class="language-plaintext highlighter-rouge">building:colour=*</code>: Define the facade’s primary material and color.</li> <li><code class="language-plaintext highlighter-rouge">roof:material=*</code> and <code class="language-plaintext highlighter-rouge">roof:colour=*</code>: Specify roof material and color.</li> </ul> </li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/roof_type-480.webp 480w,/assets/img/3dgis/roof_type-800.webp 800w,/assets/img/3dgis/roof_type-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/roof_type.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>By using this schema, OSM contributors improve data quality for richer visualization and urban analysis.</p> <hr/> <h3 id="planet-osm">Planet OSM</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/streets_Planetiler-480.webp 480w,/assets/img/3dgis/streets_Planetiler-800.webp 800w,/assets/img/3dgis/streets_Planetiler-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/streets_Planetiler.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Planetiler is a high-performance tool for generating vector tiles from geographic datasets like OSM. Designed for speed and efficiency, it can create global maps in hours on a single machine. The tool outputs data in protobuf format, categorizing it into layers like water, buildings, and transport.</p> <p>In Streets.GL, we can create a tile using <code class="language-plaintext highlighter-rouge">Tile3DFromVectorProvider</code>:</p> <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">providerParams</span><span class="p">:</span> <span class="nx">Tile3DProviderParams</span> <span class="o">=</span> <span class="p">{</span>
  <span class="cm">/* initialize params as needed */</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">tile3DProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tile3DFromVectorProvider</span><span class="p">(</span><span class="nx">providerParams</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">zoom</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">featureCollection</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">tile3DProvider</span><span class="p">.</span><span class="nf">getCollection</span><span class="p">({</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">zoom</span> <span class="p">});</span>

<span class="kd">const</span> <span class="nx">tile</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Tile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
<span class="nx">tile</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="nx">featureCollection</span><span class="p">);</span>
</code></pre></div></div> <p>Under <code class="language-plaintext highlighter-rouge">Tile3DFromVectorProvider</code>, the key components are:</p> <ol> <li> <p><strong>Tile3DFromVectorProvider:</strong> This class converts vector tile data into 3D feature collections that can be rendered in a 3D environment. It processes vector tiles to generate various 3D geometries, such as extruded buildings, projected lines, and other features.</p> </li> <li> <p><strong>Tile3DExtrudedGeometry:</strong> This interface represents extruded 3D geometries, typically used for 3D buildings. It includes various buffers for positions, UV coordinates, normals, texture IDs, colors, and IDs, along with a bounding box for the geometry.</p> </li> <li> <p><strong>RoofBuilder:</strong> This interface defines a builder for creating roof geometries for extruded 3D buildings. It includes methods and parameters for building various types of roofs, such as gabled, hipped, and flat roofs.</p> </li> <li> <p><strong>Tile3DExtrudedGeometryBuilder:</strong> This class is responsible for constructing <code class="language-plaintext highlighter-rouge">Tile3DExtrudedGeometry</code> objects. It handles the generation of walls, roofs, and other extruded features for buildings, utilizing various builders for specific roof types and other details.</p> </li> </ol> <p>Supporting OSMBuilding in production opens up numerous applications, as evidenced by Cesium’s use of OSM data. However, OSMBuilding raised concerns in 2020 over Cesium’s trademark “Cesium OSM Buildings,” fearing confusion with their own open-source project.</p> <hr/> <h2 id="others">Others</h2> <h3 id="instance-objects-in-streetsgl">Instance Objects in Streets.GL</h3> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/3dgis/streets_tree-480.webp 480w,/assets/img/3dgis/streets_tree-800.webp 800w,/assets/img/3dgis/streets_tree-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/3dgis/streets_tree.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Streets.GL supports instance objects for commonly occurring features. For example, it can draw trees in regions labeled as “plant” by instancing tree models.</p> <h3 id="terrain">Terrain</h3> <p>Streets.GL generates detailed 3D terrain using heightmaps sourced from ArcGIS Online services.</p> <h3 id="rendering">Rendering</h3> <p>The rendering pipeline incorporates advanced techniques, including deferred shading with PBR, Temporal Anti-Aliasing (TAA), realistic atmosphere effects, and aerial perspective rendering.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>Streets.GL, OSMBuilding, and related tools exemplify the powerful intersection of open-source technology and geospatial visualization. By leveraging detailed schemas like Simple 3D Buildings, advanced rendering pipelines, and efficient data tools like Planetiler, these projects provide intuitive ways to understand and interact with urban landscapes. Together, they push the boundaries of what is possible in the realm of GIS, making geographic data accessible and visually compelling for diverse applications. As these tools continue to evolve, they promise to drive innovation in fields ranging from urban planning to real-time 3D mapping.</p>]]></content><author><name></name></author><category term="3DGIS"/><category term="WebGL"/><category term="GIS"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">DDG Manifold</title><link href="https://pasu.github.io/blog/2025/ddg_manifold/" rel="alternate" type="text/html" title="DDG Manifold"/><published>2025-01-11T10:27:00+00:00</published><updated>2025-01-11T10:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/ddg_manifold</id><content type="html" xml:base="https://pasu.github.io/blog/2025/ddg_manifold/"><![CDATA[<h3 id="what-is-a-manifold">What is a Manifold?</h3> <p>A manifold is a fundamental concept in geometry that describes a “nice” space that locally looks like Euclidean space \(\mathbb{R}^n\). For instance:</p> <ul> <li>In two dimensions (\(n = 2\)), both spheres and tori are examples of manifolds because their small neighborhoods resemble \(\mathbb{R}^2\).</li> <li>A space is <strong>non-manifold</strong> if it has regions where this local resemblance breaks down, such as points where multiple surfaces intersect in a way that cannot be flattened into a Euclidean patch.</li> </ul> <p>Formally, a topological space is a <strong>manifold</strong> if:</p> <ol> <li>It is Hausdorff (any two distinct points have disjoint neighborhoods).</li> <li>Every point has a neighborhood homeomorphic to \(\mathbb{R}^n\).</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_manifold-480.webp 480w,/assets/img/DDG/4_manifold-800.webp 800w,/assets/img/DDG/4_manifold-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_manifold.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="simplicial-manifold">Simplicial Manifold</h3> <p>A <strong>simplicial \(k\)-complex</strong> is called a manifold if the <strong>link</strong> of every vertex is homeomorphic to a \((k-1)\)-dimensional sphere.</p> <ul> <li><strong>Link</strong>: The set of simplices adjacent to a vertex, excluding the vertex itself.</li> <li>Examples: <ul> <li>For \(k = 2\): The link of a vertex should form a 1-dimensional closed loop.</li> <li>For \(k = 3\): The link of a vertex should resemble a 2-dimensional sphere.</li> </ul> </li> </ul> <p>As \(k\) increases, checking whether a simplicial complex is a manifold becomes more computationally difficult. For \(k = 4\), verifying that each link is a 3-sphere is an NP-hard problem.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_mesh_simplicial_manifold-480.webp 480w,/assets/img/DDG/4_mesh_simplicial_manifold-800.webp 800w,/assets/img/DDG/4_mesh_simplicial_manifold-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_mesh_simplicial_manifold.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="manifold-meshes">Manifold Meshes</h3> <p>A <strong>manifold mesh</strong> is a triangle mesh that satisfies the following conditions:</p> <ol> <li>Every edge is shared by exactly two triangles, or just one if it lies on the boundary.</li> <li>Every vertex has a neighborhood forming a single loop of triangles or a “fan” of triangles along the boundary.</li> </ol> <p>Manifold meshes are advantageous because they have <strong>predictable neighborhoods</strong>, which simplify data structures and algorithms:</p> <ul> <li>Adjacency relationships are easier to manage.</li> <li>They are particularly useful in graphics and simulations for operations like subdivision and integration.</li> </ul> <h3 id="motivation-for-manifold-meshes">Motivation for Manifold Meshes</h3> <p>Manifold meshes provide simplicity similar to a regular pixel grid in 2D images:</p> <ul> <li>Predictable structure (e.g., each pixel has exactly four neighbors).</li> <li>Enables robust and efficient computations, especially in discrete differential geometry.</li> </ul> <hr/> <h3 id="topological-data-structures">Topological Data Structures</h3> <h4 id="adjacency-list">Adjacency List</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_manifold_adjacent_list-480.webp 480w,/assets/img/DDG/4_manifold_adjacent_list-800.webp 800w,/assets/img/DDG/4_manifold_adjacent_list-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_manifold_adjacent_list.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The <strong>adjacency list</strong> is a lightweight data structure for storing topological relationships:</p> <ul> <li><strong>What it stores</strong>: Only the top-dimensional simplices (e.g., triangles in a 2D mesh or tetrahedra in a 3D mesh).</li> <li><strong>Advantages</strong>: <ul> <li>Simple and compact in terms of memory usage.</li> <li>Works well when access to top-dimensional elements is sufficient.</li> </ul> </li> <li><strong>Drawbacks</strong>: <ul> <li>Iterating over lower-dimensional elements (e.g., edges or vertices) is computationally expensive because connections must be reconstructed on demand.</li> <li>Accessing neighbors of a simplex can be slow due to extra computation.</li> </ul> </li> </ul> <h4 id="incidence-matrix">Incidence Matrix</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_manifold_adjacent_matrix-480.webp 480w,/assets/img/DDG/4_manifold_adjacent_matrix-800.webp 800w,/assets/img/DDG/4_manifold_adjacent_matrix-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_manifold_adjacent_matrix.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The <strong>incidence matrix</strong> captures relationships between simplices of different dimensions, such as:</p> <ul> <li>Vertices and edges,</li> <li>Edges and faces,</li> <li>Faces and volumes.</li> </ul> <p>Each matrix entry indicates whether a given simplex (row) is part of another simplex (column):</p> <ul> <li><strong>Advantages</strong>: <ul> <li>Explicitly represents relationships across dimensions.</li> <li>Easy to query using matrix operations.</li> </ul> </li> <li><strong>Drawbacks</strong>: <ul> <li>Can grow large for dense meshes, wasting storage if many entries are zero.</li> </ul> </li> </ul> <p>To improve efficiency, <strong>sparse matrix data structures</strong> are often used:</p> <ol> <li><strong>Associative array</strong>: Maps nonzero entries to their locations (e.g., hash tables).</li> <li><strong>Array of linked lists</strong>: Stores nonzero entries in lists grouped by rows or columns.</li> <li><strong>Compressed column format (CCF)</strong>: <ul> <li>Stores values and row indices compactly for each column.</li> <li>Optimized for matrix operations like multiplication.</li> </ul> </li> </ol> <h4 id="signed-incidence-matrix">Signed Incidence Matrix</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_manifold_signed_adjacent_matrix-480.webp 480w,/assets/img/DDG/4_manifold_signed_adjacent_matrix-800.webp 800w,/assets/img/DDG/4_manifold_signed_adjacent_matrix-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_manifold_signed_adjacent_matrix.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The <strong>signed incidence matrix</strong> extends the basic incidence matrix by encoding the <strong>orientation</strong> of simplices:</p> <ul> <li>Each nonzero entry has a sign (\(+\) or \(-\)) that depends on the relative orientation of the two simplices.</li> <li>Commonly used in <strong>discrete exterior calculus</strong> to define operators like divergence, gradient, and curl.</li> </ul> <h4 id="half-edge-data-structure">Half-Edge Data Structure</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_manifold_half_edge-480.webp 480w,/assets/img/DDG/4_manifold_half_edge-800.webp 800w,/assets/img/DDG/4_manifold_half_edge-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_manifold_half_edge.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The <strong>half-edge data structure</strong> is an efficient way to represent the connectivity of a mesh:</p> <ul> <li><strong>Concept</strong>: Each edge in the mesh is divided into two oppositely oriented <strong>half-edges</strong>.</li> <li><strong>What it stores</strong>: <ul> <li>Relationships between vertices, edges, and faces through the connectivity of half-edges.</li> <li>Each half-edge points to: <ul> <li>Its <strong>twin</strong> (the other half of the edge),</li> <li>The <strong>next</strong> half-edge in the face,</li> <li>The vertex it originates from,</li> <li>The face it belongs to.</li> </ul> </li> </ul> </li> <li><strong>Advantages</strong>: <ul> <li>Enables efficient traversal and modification of mesh elements.</li> <li>Ideal for geometry processing and discrete differential geometry.</li> </ul> </li> <li><strong>Challenges</strong>: <ul> <li>Slightly more complex to implement.</li> <li>Uses more memory than simpler structures like adjacency lists but is far more efficient for traversal-heavy operations.</li> </ul> </li> </ul> <h3 id="summary-table-of-data-structures">Summary Table of Data Structures</h3> <table> <thead> <tr> <th><strong>Structure</strong></th> <th><strong>Advantages</strong></th> <th><strong>Drawbacks</strong></th> <th><strong>Best Use Case</strong></th> </tr> </thead> <tbody> <tr> <td><strong>Adjacency List</strong></td> <td>Simple, low memory usage</td> <td>Slow for edge/neighbor traversal</td> <td>When storage is a key concern</td> </tr> <tr> <td><strong>Incidence Matrix</strong></td> <td>Explicit relationships, easy access</td> <td>Large size without sparse optimization</td> <td>Clear representation of all relations</td> </tr> <tr> <td><strong>Signed Incidence Matrix</strong></td> <td>Adds orientation to relationships</td> <td>Similar to incidence matrix</td> <td>Discrete exterior calculus, physics-based</td> </tr> <tr> <td><strong>Half-Edge</strong></td> <td>Fast traversal, efficient operations</td> <td>Higher storage and implementation effort</td> <td>Mesh manipulation, geometry processing</td> </tr> </tbody> </table> <hr/> <h3 id="dual-complex-and-poincaré-duality">Dual Complex and Poincaré Duality</h3> <h4 id="primal-and-dual-complexes">Primal and Dual Complexes</h4> <p>A <strong>primal complex</strong> is the original simplicial complex consisting of simplices (vertices, edges, triangles, etc.) that define a geometric or topological structure. The <strong>dual complex</strong> is derived by “inverting” the roles of these elements:</p> <ul> <li><strong>Primal to Dual Mapping</strong>: <ul> <li>A \(k\)-simplex in the primal complex maps to a \((n-k)\)-cell in the dual complex.</li> <li>Example in a 2D triangular mesh: <ul> <li>A primal vertex maps to a dual cell.</li> <li>A primal edge maps to a dual edge.</li> <li>A primal triangle maps to a dual vertex.</li> </ul> </li> </ul> </li> <li><strong>Difference</strong>: <ul> <li>The primal complex emphasizes geometry.</li> <li>The dual complex emphasizes connectivity, useful for applications like flux, circulation, or integration.</li> </ul> </li> </ul> <h4 id="simplicial-complex">Simplicial Complex</h4> <p>A <strong>simplicial complex</strong> is a collection of simplices (points, edges, triangles, tetrahedra, etc.) that satisfies:</p> <ol> <li><strong>Closure</strong>: If a simplex is in the complex, all its faces are also included.</li> <li><strong>Intersection</strong>: Any two simplices in the complex intersect in either an empty set or another simplex in the complex.</li> </ol> <p>This structure is fundamental in computational topology and discrete geometry, enabling clean and efficient representations of shapes.</p> <h4 id="poincaré-dual">Poincaré Dual</h4> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/4_manifold_dual_complex-480.webp 480w,/assets/img/DDG/4_manifold_dual_complex-800.webp 800w,/assets/img/DDG/4_manifold_dual_complex-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/4_manifold_dual_complex.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The <strong>Poincaré dual</strong> is a dual structure associated with a simplicial complex, forming a <strong>cell complex</strong> where:</p> <ul> <li>Each simplex in the primal complex corresponds to a dual cell of complementary dimension.</li> <li>The connectivity of the primal determines the connectivity of the dual.</li> </ul> <p>Example:</p> <ul> <li>In a 2D simplicial complex (triangular mesh), the dual complex is a graph where: <ul> <li>Nodes represent triangles (2-simplices).</li> <li>Edges connect nodes whose triangles share a primal edge.</li> </ul> </li> </ul> <h4 id="poincaré-duality">Poincaré Duality</h4> <p>Poincaré duality is a core result in algebraic topology, linking the homology groups of a manifold to its dual:</p> <ul> <li>For an \(n\)-dimensional orientable manifold, the \(k\)-th homology group \(H_k\) is isomorphic to the \((n-k)\)-th cohomology group \(H^{n-k}\) of the dual.</li> </ul> <p>This duality is vital for understanding manifold topology, with applications in physics, geometry, and topology optimization.</p> <h4 id="poincaré-duality-in-nature">Poincaré Duality in Nature</h4> <p>Poincaré duality is prevalent in nature and engineering, often appearing implicitly in physical systems:</p> <ol> <li><strong>Biological Systems</strong>: <ul> <li>Blood vessels and tree branches exhibit dual structures optimized for flow and circulation.</li> <li>Neural networks reflect dual patterns between regions of activation and connectivity.</li> </ul> </li> <li><strong>Physics and Materials</strong>: <ul> <li>Electromagnetic flux and circulation follow dual patterns (e.g., Faraday’s law, Ampère’s law).</li> <li>Crystal lattices exhibit primal-dual relationships, such as Voronoi (dual) and Delaunay (primal) diagrams.</li> </ul> </li> <li><strong>Geology and Geography</strong>: <ul> <li>Watersheds and drainage basins show dual relationships between peaks (primal points) and valleys (dual points).</li> </ul> </li> <li><strong>Architecture</strong>: <ul> <li>Structural designs often feature primal elements (e.g., beams) with dual purposes (e.g., stress paths).</li> </ul> </li> </ol> <p>Leveraging Poincaré duality helps researchers and engineers understand the intrinsic relationships between geometry and functionality, enabling optimized designs and deeper insights into natural systems.</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[What is a Manifold?]]></summary></entry><entry><title type="html">DDG Mesh</title><link href="https://pasu.github.io/blog/2025/ddg_mesh/" rel="alternate" type="text/html" title="DDG Mesh"/><published>2025-01-08T20:27:00+00:00</published><updated>2025-01-08T20:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/ddg_mesh</id><content type="html" xml:base="https://pasu.github.io/blog/2025/ddg_mesh/"><![CDATA[<h3 id="what-is-a-mesh">What is a Mesh?</h3> <p>A mesh is a crucial structure in computational geometry and computer graphics, widely used to represent and analyze shapes, surfaces, and volumes. To fully understand a mesh, let’s explore its components and related concepts in detail.</p> <hr/> <h3 id="convex-set">Convex Set</h3> <p>A subset \(S \subset \mathbb{R}^n\) is <strong>convex</strong> if, for any two points \(p, q \in S\), the line segment connecting \(p\) and \(q\) lies entirely within \(S\).</p> <ul> <li><strong>Convex Hull</strong>: The convex hull \(\text{conv}(S)\) of a set \(S\) is the smallest convex set containing \(S\).</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/3_mesh_convex-480.webp 480w,/assets/img/DDG/3_mesh_convex-800.webp 800w,/assets/img/DDG/3_mesh_convex-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/3_mesh_convex.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h3 id="simplex">Simplex</h3> <p>A <strong>simplex</strong> is a fundamental building block of meshes, defined as the convex hull of \(k+1\) affinely independent points. Examples include:</p> <ul> <li><strong>0-simplex</strong>: A point.</li> <li><strong>1-simplex</strong>: A line segment.</li> <li><strong>2-simplex</strong>: A triangle.</li> <li><strong>3-simplex</strong>: A tetrahedron.</li> </ul> <h4 id="affine-independence">Affine Independence</h4> <p>Points \(p_1, p_2, \dots, p_k\) are affinely independent if the vectors \(p_2 - p_1, p_3 - p_1, \dots, p_k - p_1\) are linearly independent.</p> <h4 id="barycentric-coordinates">Barycentric Coordinates</h4> <p>Any point \(p\) inside a simplex can be expressed as a convex combination of its vertices:</p> \[p = \sum_{i=0}^k t_i v_i, \quad \text{where } \sum_{i=0}^k t_i = 1 \text{ and } t_i \geq 0.\] <p>The coefficients \(t_i\) are the <strong>barycentric coordinates</strong> of \(p\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/3_mesh_simplex-480.webp 480w,/assets/img/DDG/3_mesh_simplex-800.webp 800w,/assets/img/DDG/3_mesh_simplex-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/3_mesh_simplex.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="standard-n-simplex">Standard \(n\)-Simplex</h4> <p>The standard \(n\)-simplex in \(\mathbb{R}^{n+1}\) is:</p> \[\sigma = (x_0, x_1, \dots, x_n) \in \mathbb{R}^{n+1} \mid \sum_{i=0}^n x_i = 1, \ x_i \geq 0 \ \forall i.\] <hr/> <h4 id="simplicial-complex">Simplicial Complex</h4> <p>A <strong>simplicial complex</strong> is a collection of simplices that satisfies the following rules:</p> <ol> <li>The intersection of any two simplices is either empty or another simplex in the complex.</li> <li>Every face of a simplex in the complex is also part of the complex.</li> </ol> <h4 id="face-of-a-simplex">Face of a Simplex</h4> <p>A face is any simplex formed by a subset of the vertices of a given simplex.</p> <h4 id="abstract-simplicial-complex">Abstract Simplicial Complex</h4> <p>This describes the combinatorial relationships between vertices and simplices without their geometric embedding. For example, an undirected graph \(G = (V, E)\) can be interpreted as an abstract simplicial complex:</p> <ul> <li><strong>0-simplices</strong>: Vertices.</li> <li><strong>1-simplices</strong>: Edges.</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/3_mesh_simplex_complex-480.webp 480w,/assets/img/DDG/3_mesh_simplex_complex-800.webp 800w,/assets/img/DDG/3_mesh_simplex_complex-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/3_mesh_simplex_complex.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h3 id="applications">Applications</h3> <p>Simplicial complexes and meshes have diverse applications, including:</p> <ul> <li><strong>Topological Data Analysis (TDA)</strong>: Examining data connectivity using techniques like persistent homology to study features such as connected components and holes across scales.</li> <li><strong>Material Science</strong>: Investigating medium-range order in materials like glass.</li> <li><strong>Neuroscience</strong>: Analyzing structural and functional networks in the brain.</li> <li><strong>Computer Graphics</strong>: Representing 3D objects for rendering and simulations.</li> </ul> <hr/> <h3 id="vertices-edges-and-faces">Vertices, Edges, and Faces</h3> <p>For simplicial complexes:</p> <ul> <li><strong>Vertices</strong>: Points (0-simplices).</li> <li><strong>Edges</strong>: Line segments (1-simplices).</li> <li><strong>Faces</strong>: Triangles (2-simplices).</li> </ul> <p>For triangle meshes, these elements are often represented as:</p> <ul> <li>\(V\): The set of vertices.</li> <li>\(E\): The set of edges.</li> <li>\(F\): The set of faces.</li> </ul> <h3 id="anatomy-of-a-simplicial-complex">Anatomy of a Simplicial Complex</h3> <ul> <li><strong>Closure</strong>: smallest simplicial complex containing a given set of simplices</li> <li><strong>Star</strong>: union of simplices containing a given subset of simplices</li> <li><strong>Link</strong>: closure of the star minus the star of the closure</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/3_mesh_simplex2-480.webp 480w,/assets/img/DDG/3_mesh_simplex2-800.webp 800w,/assets/img/DDG/3_mesh_simplex2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/3_mesh_simplex2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h3 id="oriented-simplicial-complex">Oriented Simplicial Complex</h3> <p>An <strong>oriented simplicial complex</strong> assigns an ordering to the vertices of each simplex:</p> <ul> <li>For a 1-simplex (edge), orientation specifies the direction (e.g., \(a \to b\) vs. \(b \to a\)).</li> <li>For a 2-simplex (triangle), orientation depends on the vertex order (e.g., \((a, b, c)\) vs. \((b, c, a)\)).</li> </ul> <h4 id="relative-orientation">Relative Orientation</h4> <p>Two oriented simplices share the same relative orientation if their common face has opposite orientations when viewed from each simplex.</p> <h4 id="simplicial-complex-and-manifold">Simplicial Complex and Manifold</h4> <p>A <strong>simplicial complex</strong> is a mathematical structure that represents objects by dividing them into simple building blocks like vertices, edges, triangles, and higher-dimensional simplices. It is widely used in computational geometry to model surfaces and other topological spaces.</p> <p>A <strong>manifold</strong> is a topological space that locally resembles Euclidean space. For a 2-manifold, this means every point has a neighborhood that looks like a 2D disk. In the context of simplicial complexes, a <strong>simplicial surface</strong> is a 2-dimensional simplicial complex that satisfies the following properties:</p> <ol> <li><strong>Local Disk Structure</strong>: The link of every vertex forms a single loop of edges, and the star of every vertex forms a combinatorial disk made of triangles.</li> <li><strong>Orientability</strong>: The surface must have a consistent orientation across all its simplices, meaning you can define a continuous “normal” direction everywhere.</li> </ol> <hr/> <h4 id="simplicial-complex-and-nonmanifold-configurations">Simplicial Complex and Nonmanifold Configurations</h4> <p>Not all simplicial complexes are manifolds. Nonmanifold configurations violate the local disk property, such as:</p> <ul> <li>An edge shared by three or more triangles.</li> <li>A vertex where multiple disconnected “cones” of simplices meet.</li> </ul> <p>Such configurations are considered <strong>nonmanifold</strong>, as their local neighborhoods do not resemble Euclidean space.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/3_mesh_manifold-480.webp 480w,/assets/img/DDG/3_mesh_manifold-800.webp 800w,/assets/img/DDG/3_mesh_manifold-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/3_mesh_manifold.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h4 id="the-möbius-band-a-special-case">The Möbius Band: A Special Case</h4> <p>The <strong>Möbius band</strong> is an example of a 2-manifold that challenges our intuition.</p> <ol> <li> <p><strong>Manifold Property</strong>: The Möbius band is a 2-manifold because every point has a neighborhood that locally looks like a 2D disk. If you zoom in on any part of the Möbius band, it behaves like a typical 2D surface.</p> </li> <li> <p><strong>Non-Orientability</strong>: Unlike a standard simplicial surface, the Möbius band is <strong>non-orientable</strong>. If you move along the surface in a continuous loop, the “normal” direction flips. This makes it impossible to define a consistent orientation across the entire band.</p> </li> <li> <p><strong>Simplicial Representation</strong>: While you can represent the Möbius band using a simplicial complex, it would not qualify as a <strong>simplicial surface</strong> under the usual assumption of orientability.</p> </li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/3_mesh_mband-480.webp 480w,/assets/img/DDG/3_mesh_mband-800.webp 800w,/assets/img/DDG/3_mesh_mband-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/3_mesh_mband.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <p>By understanding meshes and their foundational components, we gain deeper insights into their structure and practical uses, from analyzing data to simulating physical systems and rendering realistic virtual environments.</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[What is a Mesh?]]></summary></entry><entry><title type="html">Array</title><link href="https://pasu.github.io/blog/2025/pbrt_array/" rel="alternate" type="text/html" title="Array"/><published>2025-01-08T10:27:00+00:00</published><updated>2025-01-08T10:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/pbrt_array</id><content type="html" xml:base="https://pasu.github.io/blog/2025/pbrt_array/"><![CDATA[<h1 id="array-in-pbrt">Array in PBRT</h1> <p>Arrays are fundamental in C++ programming, especially in performance-critical applications like PBRT. In PBRT’s utility library, <code class="language-plaintext highlighter-rouge">pstd::array</code> reimagines <code class="language-plaintext highlighter-rouge">std::array</code> with specific tweaks for rendering needs. This post delves into the features of <code class="language-plaintext highlighter-rouge">pstd::array</code>, its differences from <code class="language-plaintext highlighter-rouge">std::array</code>, the advantages of arrays over raw pointers, and using arrays with modern C++ techniques, including <code class="language-plaintext highlighter-rouge">std::move</code> and <code class="language-plaintext highlighter-rouge">std::span</code>.</p> <hr/> <h2 id="understanding-pstdarray">Understanding <code class="language-plaintext highlighter-rouge">pstd::array</code></h2> <p>The <code class="language-plaintext highlighter-rouge">pstd::array</code> class in PBRT mirrors much of the functionality of <code class="language-plaintext highlighter-rouge">std::array</code> but is customized to meet the demands of rendering workflows. Here’s a glimpse of its structure:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">array</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">*</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">const</span> <span class="n">value_type</span> <span class="o">*</span><span class="p">;</span>

    <span class="n">array</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">array</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">val</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">fill</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">T</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>

    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">values</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">values</span> <span class="o">+</span> <span class="n">N</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">values</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">values</span> <span class="o">+</span> <span class="n">N</span><span class="p">;</span> <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">N</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">values</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="key-features-of-pstdarray">Key Features of <code class="language-plaintext highlighter-rouge">pstd::array</code></h3> <ol> <li><strong>Static Size</strong>: Provides a fixed-size, stack-allocated array, similar to <code class="language-plaintext highlighter-rouge">std::array</code>.</li> <li><strong>Initializer List Support</strong>: Enables initialization with syntax like: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
</code></pre></div> </div> </li> <li><strong>Iterator Support</strong>: Works seamlessly with range-based loops.</li> <li><strong>Environment Adaptability</strong>: Compatibility across CPU and GPU environments through <code class="language-plaintext highlighter-rouge">PBRT_CPU_GPU</code> macros.</li> </ol> <hr/> <h2 id="differences-between-pstdarray-and-stdarray">Differences Between <code class="language-plaintext highlighter-rouge">pstd::array</code> and <code class="language-plaintext highlighter-rouge">std::array</code></h2> <h3 id="1-initializer-list-constructor">1. <strong>Initializer List Constructor</strong></h3> <p><code class="language-plaintext highlighter-rouge">pstd::array</code> explicitly defines a constructor for <code class="language-plaintext highlighter-rouge">std::initializer_list</code>, making syntax like:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
</code></pre></div></div> <p>possible. However, it does not enforce bounds checking, so mismatched list sizes can result in undefined behavior. By contrast, <code class="language-plaintext highlighter-rouge">std::array</code> relies on compiler mechanisms for safer initialization without explicitly defining such a constructor.</p> <h3 id="2-minimal-dependencies">2. <strong>Minimal Dependencies</strong></h3> <p><code class="language-plaintext highlighter-rouge">pstd::array</code> avoids STL dependencies, keeping it lightweight and tailored to PBRT’s performance-focused requirements.</p> <h3 id="3-cpu-gpu-compatibility">3. <strong>CPU-GPU Compatibility</strong></h3> <p><code class="language-plaintext highlighter-rouge">pstd::array</code> ensures cross-platform compatibility using the <code class="language-plaintext highlighter-rouge">PBRT_CPU_GPU</code> macros, a feature absent in <code class="language-plaintext highlighter-rouge">std::array</code>.</p> <hr/> <h2 id="arrays-vs-pointers-for-memory-management">Arrays vs. Pointers for Memory Management</h2> <p>In rendering systems, raw pointers often manage memory blocks like image or texture data. Replacing pointers with fixed-size arrays brings notable advantages:</p> <h3 id="benefits-of-arrays-over-pointers">Benefits of Arrays over Pointers</h3> <ol> <li><strong>Safety</strong>: Arrays encapsulate their size, reducing out-of-bounds errors.</li> <li><strong>Optimization</strong>: Known size at compile time allows for better compiler optimizations.</li> <li><strong>Readability</strong>: Range-based loops and STL integration make code clearer and less error-prone.</li> </ol> <h3 id="example-using-pstdarray-for-image-data">Example: Using <code class="language-plaintext highlighter-rouge">pstd::array</code> for Image Data</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">256</span><span class="o">&gt;</span> <span class="n">image</span><span class="p">;</span>
<span class="n">image</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// Initialize all pixels to black</span>

<span class="c1">// Set a pixel value</span>
<span class="n">image</span><span class="p">[</span><span class="mi">128</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span> <span class="c1">// Center pixel set to white</span>

<span class="c1">// Iterate over pixels</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">pixel</span> <span class="o">:</span> <span class="n">image</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Process each pixel</span>
<span class="p">}</span>
</code></pre></div></div> <p>This approach is safer and easier to maintain compared to raw pointer-based alternatives.</p> <hr/> <h2 id="arrays-and-stdspan">Arrays and <code class="language-plaintext highlighter-rouge">std::span</code></h2> <p>Introduced in C++20, <code class="language-plaintext highlighter-rouge">std::span</code> provides a non-owning view over a contiguous memory block, making it an excellent alternative to raw pointers when passing arrays to functions.</p> <h3 id="benefits-of-stdspan">Benefits of <code class="language-plaintext highlighter-rouge">std::span</code></h3> <ol> <li><strong>Safety</strong>: Encapsulates size information, minimizing out-of-bounds access risks.</li> <li><strong>Flexibility</strong>: Works with <code class="language-plaintext highlighter-rouge">std::array</code>, <code class="language-plaintext highlighter-rouge">std::vector</code>, raw arrays, or custom containers like <code class="language-plaintext highlighter-rouge">pstd::array</code>.</li> <li><strong>Simplicity</strong>: Simplifies function parameters by removing the need for separate size arguments.</li> </ol> <h3 id="example-using-stdspan-as-a-function-parameter">Example: Using <code class="language-plaintext highlighter-rouge">std::span</code> as a Function Parameter</h3> <h4 id="raw-pointer-version">Raw Pointer Version</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">processArray</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The caller must provide both the pointer and size, which can lead to errors.</p> <h4 id="using-stdspan">Using <code class="language-plaintext highlighter-rouge">std::span</code></h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;span&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">processArray</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">value</span> <span class="o">:</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This version is safer and more versatile. It allows:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">processArray</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
<span class="n">processArray</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
</code></pre></div></div> <p>The encapsulated size improves safety and readability while maintaining compatibility with legacy APIs using pointers.</p> <hr/> <h2 id="modern-c-techniques-with-arrays">Modern C++ Techniques with Arrays</h2> <h3 id="using-stdmove">Using <code class="language-plaintext highlighter-rouge">std::move</code></h3> <p><code class="language-plaintext highlighter-rouge">std::move</code> transfers ownership of resources. However, for fixed-size arrays like <code class="language-plaintext highlighter-rouge">pstd::array</code>, explicit <code class="language-plaintext highlighter-rouge">std::move</code> is unnecessary in many cases due to:</p> <ol> <li><strong>Stack Allocation</strong>: Data is not dynamically managed.</li> <li><strong>Return Value Optimization (RVO)</strong>: Modern compilers eliminate redundant copies when returning arrays.</li> </ol> <h4 id="example-leveraging-rvo">Example: Leveraging RVO</h4> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">createArray</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="p">}</span>

<span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">createArray</span><span class="p">();</span>
</code></pre></div></div> <p>RVO ensures the array is constructed directly in its final location.</p> <h3 id="range-based-loops">Range-Based Loops</h3> <p>Both <code class="language-plaintext highlighter-rouge">pstd::array</code> and <code class="language-plaintext highlighter-rouge">std::array</code> integrate seamlessly with range-based loops:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">value</span> <span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="passing-arrays-to-functions">Passing Arrays to Functions</h3> <p>Always pass arrays by reference to avoid unnecessary copies:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">processArray</span><span class="p">(</span><span class="k">const</span> <span class="n">pstd</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">value</span> <span class="o">:</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <hr/> <h2 id="conclusion">Conclusion</h2> <p>The <code class="language-plaintext highlighter-rouge">pstd::array</code> in PBRT offers a flexible, lightweight alternative to <code class="language-plaintext highlighter-rouge">std::array</code> while catering to the specialized needs of rendering. Combining this with modern C++ tools like <code class="language-plaintext highlighter-rouge">std::span</code> and techniques like RVO enables developers to write safer, more efficient, and expressive code without resorting to raw pointers.</p> <p>When I began using C++ around 2006, pointers were highly encouraged as an alternative to C-style arrays for achieving high performance. At the time, the programming community was enamored with pointers, often likening them to a sharp knife—capable of causing harm if mishandled but far more effective than a blunt tool. Fast forward to today, much has changed in programming practices, and fortunately, C++ continues to thrive.</p>]]></content><author><name></name></author><category term="C++"/><category term="ModernC++"/><category term="Pbrt"/><summary type="html"><![CDATA[Array in PBRT]]></summary></entry><entry><title type="html">Traits</title><link href="https://pasu.github.io/blog/2025/Pbrt_Traits/" rel="alternate" type="text/html" title="Traits"/><published>2025-01-06T10:27:00+00:00</published><updated>2025-01-06T10:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/Pbrt_Traits</id><content type="html" xml:base="https://pasu.github.io/blog/2025/Pbrt_Traits/"><![CDATA[<h1 id="designing-traits-in-c">Designing Traits in C++</h1> <p>Traits are a powerful design pattern in C++ that allow you to associate compile-time metadata and behaviors with specific types. This tutorial explores how traits are used in the <code class="language-plaintext highlighter-rouge">pbrt</code> project to handle parameter parsing for various types, illustrating how traits can simplify type-specific behavior and make code cleaner and more extensible.</p> <hr/> <h2 id="example-overview-parameter-dictionary">Example Overview: Parameter Dictionary</h2> <p>The <code class="language-plaintext highlighter-rouge">ParameterDictionary</code> class manages parameters of various types, such as integers and floats. Each type has unique behaviors for conversion, retrieval, and metadata. Using traits, we can define these behaviors in a type-safe and organized way.</p> <hr/> <h2 id="step-1-define-the-traits-template">Step 1: Define the Traits Template</h2> <p>Begin by creating a generic template for traits:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">ParameterType</span> <span class="n">PT</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span> <span class="p">{};</span>
</code></pre></div></div> <p>This serves as the base structure. Specializations of this template will define type-specific behavior.</p> <hr/> <h2 id="step-2-create-specializations-for-each-type">Step 2: Create Specializations for Each Type</h2> <p>For every supported type, provide a specialization of <code class="language-plaintext highlighter-rouge">ParameterTypeTraits</code> to define its behavior and metadata. For example:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">ParameterType</span><span class="o">::</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">typeName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"integer"</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">nPerItem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="n">Convert</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>  <span class="c1">// Example conversion logic</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">GetValues</span><span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">ints</span><span class="p">;</span>  <span class="c1">// Retrieve integer values</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">ParameterType</span><span class="o">::</span><span class="n">Float</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">typeName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"float"</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">nPerItem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="kt">float</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">float</span> <span class="n">Convert</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>  <span class="c1">// Example conversion logic</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">GetValues</span><span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">floats</span><span class="p">;</span>  <span class="c1">// Retrieve float values</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="key-components">Key Components:</h3> <ul> <li><strong><code class="language-plaintext highlighter-rouge">typeName</code></strong>: Describes the parameter type.</li> <li><strong><code class="language-plaintext highlighter-rouge">nPerItem</code></strong>: Specifies how many elements are in one item.</li> <li><strong><code class="language-plaintext highlighter-rouge">ReturnType</code></strong>: Defines the return type for retrieved values.</li> <li><strong><code class="language-plaintext highlighter-rouge">Convert</code></strong>: Handles type-specific conversion logic.</li> <li><strong><code class="language-plaintext highlighter-rouge">GetValues</code></strong>: Retrieves values from a <code class="language-plaintext highlighter-rouge">ParsedParameter</code> object.</li> </ul> <hr/> <h2 id="step-3-use-traits-in-generic-functions">Step 3: Use Traits in Generic Functions</h2> <p>The <code class="language-plaintext highlighter-rouge">ParameterDictionary</code> class can now leverage these traits to implement type-specific logic. For instance:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="n">ParameterType</span> <span class="n">PT</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">PT</span><span class="o">&gt;::</span><span class="n">ReturnType</span><span class="o">&gt;</span>
<span class="n">ParameterDictionary</span><span class="o">::</span><span class="n">lookupArray</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">traits</span> <span class="o">=</span> <span class="n">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">PT</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">lookupArray</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">traits</span><span class="o">::</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">PT</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">typeName</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">nPerItem</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">GetValues</span><span class="p">,</span> <span class="n">traits</span><span class="o">::</span><span class="n">Convert</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>This function:</p> <ul> <li>Extracts type-specific details from the corresponding <code class="language-plaintext highlighter-rouge">ParameterTypeTraits</code> specialization.</li> <li>Passes these details to another function for further processing.</li> </ul> <hr/> <h2 id="step-4-implement-helper-functions-using-traits">Step 4: Implement Helper Functions Using Traits</h2> <p>To implement core logic, a helper function can use the traits’ members:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">ReturnType</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">G</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span> <span class="n">ParameterDictionary</span><span class="o">::</span><span class="n">lookupArray</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span>
                                                         <span class="n">ParameterType</span> <span class="n">type</span><span class="p">,</span>
                                                         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">typeName</span><span class="p">,</span>
                                                         <span class="kt">int</span> <span class="n">nPerItem</span><span class="p">,</span> <span class="n">G</span> <span class="n">getValues</span><span class="p">,</span>
                                                         <span class="n">C</span> <span class="n">convert</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">*</span><span class="n">p</span> <span class="o">:</span> <span class="n">params</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">typeName</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">returnArray</span><span class="o">&lt;</span><span class="n">ReturnType</span><span class="o">&gt;</span><span class="p">(</span><span class="n">getValues</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">),</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">nPerItem</span><span class="p">,</span> <span class="n">convert</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{};</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="explanation">Explanation:</h3> <ul> <li><strong><code class="language-plaintext highlighter-rouge">getValues</code></strong> and <strong><code class="language-plaintext highlighter-rouge">convert</code></strong> are passed as arguments derived from the traits.</li> <li>They enable type-specific operations without requiring hard-coded logic.</li> </ul> <hr/> <h2 id="step-5-ensure-traits-members-are-static">Step 5: Ensure Traits Members Are Static</h2> <p>For this design to work seamlessly, traits’ functions such as <code class="language-plaintext highlighter-rouge">Convert</code> and <code class="language-plaintext highlighter-rouge">GetValues</code> should be <code class="language-plaintext highlighter-rouge">static</code>. This allows them to be called without creating an instance of <code class="language-plaintext highlighter-rouge">ParameterTypeTraits</code>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">traits</span><span class="o">::</span><span class="n">GetValues</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// Works because GetValues is static</span>
</code></pre></div></div> <hr/> <h2 id="why-use-traits">Why Use Traits?</h2> <h3 id="advantages-of-the-traits-pattern">Advantages of the Traits Pattern:</h3> <ol> <li><strong>Decoupling Logic</strong>: Each type’s behavior is encapsulated within its specialization.</li> <li><strong>Compile-Time Optimizations</strong>: Decisions based on type occur at compile time, improving efficiency.</li> <li><strong>Reusability</strong>: Shared logic for type-specific operations can be reused across functions.</li> <li><strong>Extensibility</strong>: Adding support for a new type requires only a new specialization.</li> </ol> <hr/> <h2 id="extending-the-traits">Extending the Traits</h2> <p>For instance, to support <code class="language-plaintext highlighter-rouge">std::string</code> parameters, add another specialization:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">ParameterTypeTraits</span><span class="o">&lt;</span><span class="n">ParameterType</span><span class="o">::</span><span class="n">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">typeName</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"string"</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">nPerItem</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">ReturnType</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Convert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// Example conversion logic</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">GetValues</span><span class="p">(</span><span class="k">const</span> <span class="n">ParsedParameter</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">strings</span><span class="p">;</span>  <span class="c1">// Retrieve string values</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div> <p>This integrates seamlessly with functions like <code class="language-plaintext highlighter-rouge">lookupArray</code> without requiring further changes.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>The traits pattern offers a clean and extensible approach to managing type-specific behavior in C++. By encapsulating type logic in traits, you can achieve strong type safety, separation of concerns, and efficient compile-time operations. Use this tutorial as a guide to designing your own traits for robust and maintainable C++ code.</p>]]></content><author><name></name></author><category term="C++"/><category term="ModernC++"/><category term="Pbrt"/><summary type="html"><![CDATA[Designing Traits in C++]]></summary></entry><entry><title type="html">DDG Curvature</title><link href="https://pasu.github.io/blog/2025/DDG_Curvature/" rel="alternate" type="text/html" title="DDG Curvature"/><published>2025-01-04T20:27:00+00:00</published><updated>2025-01-04T20:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/DDG_Curvature</id><content type="html" xml:base="https://pasu.github.io/blog/2025/DDG_Curvature/"><![CDATA[<h3 id="exploring-curvature">Exploring Curvature</h3> <p>A <strong>continuous curve</strong> is a fundamental concept in mathematics, appearing in fields ranging from physics to computer graphics. Understanding its properties, such as the tangent, normal, and curvature, provides valuable insights into its geometry and behavior. Let’s delve into these ideas in detail.</p> <hr/> <h3 id="what-is-a-continuous-curve">What Is a Continuous Curve?</h3> <p>A <strong>parameterized curve</strong> in the 2D plane can be defined as a mapping:</p> \[\gamma(s): [0, L] \to \mathbb{R}^2\] <p>where:</p> <ul> <li><strong>s</strong> is the parameter, often representing arc length, defined in the interval \([0, L]\).</li> <li>\(\gamma(s) = (x(s), y(s))\) specifies the position of a point on the curve.</li> </ul> <hr/> <h3 id="tangent-vector-of-a-curve">Tangent Vector of a Curve</h3> <p>The <strong>tangent vector</strong> gives the direction of the curve at a specific point \(\gamma(s)\). It is defined as the derivative of the curve with respect to the parameter \(s\):</p> \[T(s) = \frac{d}{ds} \gamma(s) = \left(\frac{dx}{ds}, \frac{dy}{ds}\right)\] <p>If the curve is <strong>arc-length parameterized</strong> (where \(s\) directly measures the distance along the curve).</p> <p>The tangent vector points in the direction in which the curve is moving at \(\gamma(s)\), making it an essential tool for understanding the geometry of the curve.</p> <hr/> <h3 id="normal-vector-of-a-curve">Normal Vector of a Curve</h3> <p>The <strong>normal vector</strong> is perpendicular to the tangent vector and provides the “sideways” direction of the curve at a given point. In 2D, the normal vector is obtained by performing a quarter-turn rotation (90° counter-clockwise) on the tangent vector. This is achieved using the <strong>rotation operator</strong>:</p> \[\mathcal{R}(x, y) = (-y, x)\] <p>Thus, for a tangent vector \(T(s) = (T_x(s), T_y(s))\), the normal vector \(N(s)\) is:</p> \[N(s) = (-T_y(s), T_x(s))\] <p>The tangent and normal vectors satisfy the following:</p> <ul> <li>They are orthogonal: \(T(s) \cdot N(s) = 0\).</li> <li>\(T(s)\) represents the direction of the curve’s motion, while \(N(s)\) represents the direction perpendicular to it.</li> </ul> <hr/> <h3 id="curvature-of-a-curve">Curvature of a Curve</h3> <p>The <strong>curvature</strong> quantifies how sharply a curve bends at a given point. It is defined as the rate of change of the tangent vector \(T(s)\) with respect to the arc-length parameter \(s\):</p> \[\kappa(s) = \left\|\frac{dT(s)}{ds}\right\|\] <p>In simple terms, curvature measures how quickly the direction of the tangent vector changes as you move along the curve.</p> <h4 id="geometric-interpretation">Geometric Interpretation</h4> <ul> <li><strong>High Curvature</strong>: The curve bends sharply.</li> <li><strong>Low Curvature</strong>: The curve is almost straight.</li> <li>For a <strong>circle</strong> of radius \(r\), the curvature is constant everywhere: \(\kappa = \frac{1}{r}\).</li> </ul> <h4 id="signed-curvature">Signed Curvature</h4> <p>In 2D, curvature can also carry a <strong>sign</strong> to indicate the direction of bending:</p> <ul> <li><strong>Positive curvature</strong>: The curve bends counter-clockwise.</li> <li><strong>Negative curvature</strong>: The curve bends clockwise.</li> </ul> <p>The signed curvature is often computed as:</p> \[\kappa(s) = \frac{\det(\gamma'(s), \gamma''(s))}{\|\gamma'(s)\|^3}\] <p>where \(\det(\gamma'(s), \gamma''(s))\) is the determinant of the tangent and second derivative vectors, capturing the orientation of the bend.</p> <hr/> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/smooth_curve-480.webp 480w,/assets/img/DDG/smooth_curve-800.webp 800w,/assets/img/DDG/smooth_curve-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/smooth_curve.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h3 id="summary-of-relationships">Summary of Relationships</h3> <ol> <li><strong>Tangent Vector \(T(s)\)</strong>: Indicates the direction of motion.</li> <li><strong>Normal Vector \(N(s)\)</strong>: Points perpendicular to \(T(s)\), describing the sideways direction.</li> <li><strong>Curvature \(\kappa(s)\)</strong>: Measures the rate of bending of the curve.</li> </ol> <p>These elements together form the core tools for studying and analyzing the geometry of curves, enabling applications from path planning in robotics to the study of dynamic systems.</p> <hr/> <h3 id="discrete-curvature">Discrete Curvature</h3> <p>A <strong>discrete curve</strong> is a piecewise linear parameterized curve, defined as a sequence of vertices \(\{\gamma_i\}\), connected by straight line segments. Unlike smooth curves, discrete curves do not have a continuous tangent or curvature, which poses challenges in defining curvature. Direct application of curvature definitions from smooth curves results in values that are either zero (for straight segments) or infinite (at sharp corners).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/discrete_curve-480.webp 480w,/assets/img/DDG/discrete_curve-800.webp 800w,/assets/img/DDG/discrete_curve-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/discrete_curve.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>To address this, we use <strong>approximations of curvature</strong> based on discrete geometry concepts.</p> <h4 id="turning-angle">Turning Angle</h4> <p>One approach to defining discrete curvature is through the <strong>turning angle</strong> at each vertex of the curve. For a vertex \(\gamma_i\), the turning angle is defined as the angle between the vectors \((\gamma_i - \gamma_{i-1})\) and \((\gamma_{i+1} - \gamma_i)\):</p> \[\theta_i = \text{angle}(\gamma_i - \gamma_{i-1}, \gamma_{i+1} - \gamma_i).\] <p>The curvature at vertex \(i\) can then be approximated as the turning angle normalized by some measure, such as the arc length between the vertices. For simplicity:</p> \[\kappa_i = \theta_i,\] <p>This mathematical formulation expresses the <strong>variation of the curve length</strong> due to a perturbation \(\eta(s)\). Let’s improve the explanation around this concept to clarify its significance and provide proper context.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/turning_angle-480.webp 480w,/assets/img/DDG/turning_angle-800.webp 800w,/assets/img/DDG/turning_angle-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/turning_angle.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h4 id="length-variation-of-a-curve">Length Variation of a Curve</h4> <p>Given a smooth parameterized curve \(\gamma(s)\), we consider a perturbation of the curve by a smooth function \(\eta(s)\), which modifies the original curve as:</p> \[\gamma_\epsilon(s) = \gamma(s) + \epsilon \eta(s),\] <p>where \(\epsilon\) is a small parameter. The goal is to evaluate how the length of the curve changes under this perturbation at \(\epsilon = 0\).</p> <h5 id="length-functional">Length Functional</h5> <p>The length of the perturbed curve \(\gamma_\epsilon(s)\) is given by:</p> \[\text{Length}(\gamma_\epsilon) = \int_0^{L} \|\gamma_\epsilon'(s)\| \, ds.\] <p>Differentiating the length functional with respect to \(\epsilon\) and evaluating at \(\epsilon = 0\), we get the length variation:</p> \[\frac{d}{d\epsilon}\Big|_{\epsilon=0} \text{Length}(\gamma_\epsilon) = -\int_0^L \langle \eta(s), \kappa(s)N(s) \rangle \, ds,\] <p>where:</p> <ul> <li>\(\eta(s)\) is the perturbation function, representing the deformation of the curve.</li> <li>\(\kappa(s)\) is the curvature of the curve at each point.</li> <li>\(N(s)\) is the unit normal vector to the curve.</li> <li>\(\langle \cdot, \cdot \rangle\) denotes the dot product in \(\mathbb{R}^2\).</li> </ul> <h5 id="geometric-interpretation-1">Geometric Interpretation</h5> <p>This formula reveals that the change in length depends on:</p> <ol> <li>The <strong>projection of the perturbation</strong> \(\eta(s)\) onto the normal direction \(N(s)\).</li> <li>The <strong>curvature</strong> \(\kappa(s)\) of the curve.</li> </ol> <p>Therefore, the motion that most quickly decreases length is \(\eta = \kappa N\). And it becomes much easier in the discrete setting: just take the gradient of length with respect to vertex positions.</p> <p>In the discrete setting, the motion that minimizes the length of a curve at each vertex can be expressed in terms of the <strong>turning angle</strong> at that vertex. Specifically, the gradient of the curve length becomes proportional to \(2 \sin(\theta_i / 2) N_i\), where \(\theta_i\) is the angle between the adjacent edges at vertex \(i\), and \(N_i\) is the normal direction at that vertex. Let’s break this down:</p> <h5 id="discrete-length-and-turning-angle">Discrete Length and Turning Angle</h5> <p>For a discrete curve, the total length is:</p> \[\text{Length}(\gamma) = \sum_{i=1}^n \|\gamma_i - \gamma_{i-1}\|,\] <p>The turning angle \(\theta_i\) at a vertex is the angle between the two adjacent edges:</p> \[\theta_i = \text{angle}(\gamma_i - \gamma_{i-1}, \gamma_{i+1} - \gamma_i).\] <h5 id="gradient-of-length">Gradient of Length</h5> <p>At each vertex, the gradient of the length \(\nabla_{\gamma_i} \text{Length}(\gamma)\) (from earlier) is derived as:</p> \[\nabla_{\gamma_i} \text{Length}(\gamma) = \frac{\gamma_i - \gamma_{i-1}}{\|\gamma_i - \gamma_{i-1}\|} + \frac{\gamma_i - \gamma_{i+1}}{\|\gamma_{i+1} - \gamma_i\|}.\] <p>This gradient can be interpreted geometrically in terms of \(\theta_i\) and the <strong>unit normal vector</strong> \(N_i\). It simplifies to:</p> \[\nabla_{\gamma_i} \text{Length}(\gamma) = 2 \sin\left(\frac{\theta_i}{2}\right) N_i,\] <p>where:</p> <ul> <li>\(\theta_i/2\) is half the turning angle.</li> <li>\(N_i\) is the inward or outward unit normal at vertex \(i\), depending on the curve’s orientation.</li> </ul> <p>The gradient of length is equal to the curvature times the normal, we have the second equivalent definition as length variation:</p> \[\kappa_i^B = 2 \sin\left(\frac{\theta_i}{2}\right)\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/length_variation-480.webp 480w,/assets/img/DDG/length_variation-800.webp 800w,/assets/img/DDG/length_variation-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/length_variation.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h4 id="relationship-between-the-two">Relationship Between the Two</h4> <p>For small \(\theta_i\) (when the curve bends only slightly):</p> \[\kappa_i^B \approx \theta_i,\] <p>since \(\sin(\theta_i / 2) \approx \theta_i / 2\) when \(\theta_i\) is small.</p> <p>This shows that the <strong>length variation</strong> curvature (\(\kappa_i^B\)) is a refined and scaled version of the <strong>turning angle</strong> curvature (\(\kappa_i^A\)), particularly useful when considering the discrete gradient of the curve’s length.</p> <hr/> <h4 id="steiner-formula-for-smooth-curves">Steiner Formula for Smooth Curves</h4> <p>The <strong>Steiner Formula</strong> provides a powerful connection between the geometry of a curve and how its length changes as the curve is offset in the normal direction. Here’s the explanation in detail:</p> <p>If a smooth curve \(\gamma\) is moved at a constant distance \(\epsilon\) in the <strong>normal direction</strong>, then the new length of the curve is given by:</p> \[\text{Length}(\gamma + \epsilon N) = \text{Length}(\gamma) - \epsilon \int_0^L \kappa(s) \, ds.\] <h5 id="key-insights">Key Insights:</h5> <ol> <li><strong>Offset Motion</strong>: Moving in the normal direction affects the length of the curve proportionally to the <strong>total curvature</strong>, i.e., the integral of \(\kappa(s)\) along the arc length.</li> <li><strong>Geometric Meaning</strong>: If the curve bends a lot (high curvature), offsetting it decreases the length more significantly. For flat or nearly straight curves, the change in length is minimal.</li> </ol> <h5 id="discrete-setting">Discrete Setting</h5> <p>In discrete curves, we offset each edge segment of the curve. The challenge lies in connecting these new offset segments consistently. Several natural strategies include:</p> <h6 id="a-circular-arc-of-radius-epsilon">A. Circular Arc of Radius \(\epsilon\):</h6> <ul> <li>Each corner is joined with a small arc, mimicking the curvature of the original smooth curve.</li> <li>This approach approximates the smooth curve behavior, including how curvature influences the overall length.</li> </ul> <h6 id="b-straight-line-connection">B. Straight Line Connection:</h6> <ul> <li>Offset segments are connected by straight lines.</li> <li>Simpler to implement but less faithful to smooth curvature effects.</li> </ul> <h6 id="c-extending-edges-until-intersection">C. Extending Edges Until Intersection:</h6> <ul> <li>Extend the offset edges until they intersect, creating natural meeting points between segments.</li> <li>Reflects how many engineering applications handle discrete curves but introduces additional sharp features.</li> </ul> <p>These equations express the <strong>length variation</strong> of a discrete curve under different curvature approximations, using turning angle (\(\theta_i\)) and its trigonometric variants. Let’s clarify the context and interpretation:</p> \[\text{Length}_A = \text{Length}(\gamma) - \epsilon \sum_i \theta_i\] \[\text{Length}_B = \text{Length}(\gamma) - \epsilon \sum_i 2 \sin\left(\frac{\theta_i}{2}\right)\] \[\text{Length}_C = \text{Length}(\gamma) - \epsilon \sum_i 2 \tan\left(\frac{\theta_i}{2}\right)\] <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/stein-480.webp 480w,/assets/img/DDG/stein-800.webp 800w,/assets/img/DDG/stein-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/stein.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h5 id="small-theta_i-approximation">Small \(\theta_i\) Approximation</h5> <p>For small \(\theta_i\), we can use:</p> \[\sin\left(\frac{\theta_i}{2}\right) \approx \tan\left(\frac{\theta_i}{2}\right) \approx \frac{\theta_i}{2}.\] <p>This makes all three formulas effectively equivalent when the turning angles are small. However, for larger angles, \(\sin(\theta_i / 2)\) and \(\tan(\theta_i / 2)\) offer better approximations.</p> <hr/> <h4 id="osculating-circle">Osculating Circle</h4> <p>The <strong>osculating circle</strong> is the circle that best approximates a smooth curve at a given point.</p> <ul> <li>Its radius matches the radius of curvature of the curve, i.e., it captures the curve’s local bending behavior.</li> <li>The <strong>curvature</strong> \(\kappa\) of the curve is the reciprocal of the osculating circle’s radius:</li> </ul> \[\kappa = \frac{1}{R}.\] <p>This geometric approach provides a simple and intuitive way to understand curvature as the “tightness” of bending.</p> <p>In the discrete setting, an analogous concept involves the <strong>circumcircle</strong> passing through three consecutive vertices of a discrete curve:</p> \[\kappa_i^D = \frac{1}{R_i} = \frac{2 \sin(\theta_i)}{\omega_i}\] <p>where \(R_i\) is the circumcircle radius for the vertices \(v_{i-1}, v_i, v_{i+1}\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/osculating-480.webp 480w,/assets/img/DDG/osculating-800.webp 800w,/assets/img/DDG/osculating-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/osculating.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <h5 id="comparison-with-other-curvature-approximations">Comparison with Other Curvature Approximations</h5> <p>The osculating circle method differs from previous discrete curvature approximations, such as the turning angle or length variation, in its direct connection to geometric properties:</p> <ol> <li><strong>Turning Angle</strong>: Measures the rate of direction change without explicit geometric constructs.</li> <li><strong>Length Variation</strong>: Relates to changes in curve length when offset, often smoothed over multiple vertices.</li> <li><strong>Osculating Circle</strong>: Provides a direct geometric measure based on the localized radius of bending, connecting smoothly to the smooth setting.</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/DDG/four-480.webp 480w,/assets/img/DDG/four-800.webp 800w,/assets/img/DDG/four-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/DDG/four.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h4 id="key-properties-of-curvature-flows">Key Properties of Curvature Flows</h4> <p>When studying curvature-based flows on curves, there are several fundamental properties that help in understanding their behavior:</p> <ol> <li> <p><strong>Total Curvature</strong> <strong>Property</strong>: The <strong>total curvature</strong> remains constant throughout the flow.</p> <ul> <li>For smooth curves, the total curvature is \(\int_0^L \kappa(s) \, ds\).</li> <li>In the discrete case, the total curvature is typically expressed as \(\sum_i \kappa_i\) (using one of the discrete definitions of curvature).</li> <li>This conservation is tied to intrinsic geometric properties of the curve.</li> </ul> </li> <li> <p><strong>Drift</strong> <strong>Property</strong>: The center of mass of the curve does not drift from the origin during the flow.</p> <ul> <li> <p>For a parameterized curve \(\gamma(s)\), the center of mass is given by:</p> \[\text{Center of Mass} = \frac{1}{L} \int_0^L \gamma(s) \, ds.\] </li> <li> <p>The non-drifting property ensures that the motion of the curve due to curvature flow does not introduce translational shifts in the overall system.</p> </li> </ul> </li> <li> <p><strong>Roundness (Stationary for Circular Curves)</strong> <strong>Property</strong>: Up to rescaling, the flow is stationary for circular curves.</p> <ul> <li>Circular curves represent an equilibrium state under curvature flows because their curvature \(\kappa = 1/r\) is constant everywhere.</li> <li>This means that circular shapes simply contract (or expand) uniformly during the flow but retain their geometry.</li> <li>The radius of the circle may change over time, but the overall shape remains a perfect circle.</li> </ul> </li> </ol> <table> <thead> <tr> <th style="text-align: left"> </th> <th style="text-align: center">Total</th> <th style="text-align: right">Drift</th> <th style="text-align: right">Round</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">\(\kappa^A\)</td> <td style="text-align: center">√</td> <td style="text-align: right">×</td> <td style="text-align: right">×</td> </tr> <tr> <td style="text-align: left">\(\kappa^B\)</td> <td style="text-align: center">×</td> <td style="text-align: right">√</td> <td style="text-align: right">×</td> </tr> <tr> <td style="text-align: left">\(\kappa^D\)</td> <td style="text-align: center">×</td> <td style="text-align: right">×</td> <td style="text-align: right">√</td> </tr> </tbody> </table> <p>No choice of discrete curvature simultaneously captures all three properties of the smooth flow.</p> <h3 id="conclusion">Conclusion</h3> <p>Curvature and its related properties, such as tangent vectors, normal vectors, and curvature flows, provide a fundamental framework for understanding the geometry of curves in both smooth and discrete settings. Key concepts like the Steiner formula, osculating circle, and curvature approximations help quantify and analyze the bending and motion of curves. While no single discrete curvature captures all the properties of smooth flows, these tools collectively enable deeper exploration and application of geometric principles in various fields, from robotics to computer graphics.</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[Exploring Curvature]]></summary></entry><entry><title type="html">Tokenizer and ParserTarget</title><link href="https://pasu.github.io/blog/2025/Pbrt_Token/" rel="alternate" type="text/html" title="Tokenizer and ParserTarget"/><published>2025-01-04T15:27:00+00:00</published><updated>2025-01-04T15:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/Pbrt_Token</id><content type="html" xml:base="https://pasu.github.io/blog/2025/Pbrt_Token/"><![CDATA[<p>PBRT (Physically Based Rendering Toolkit) is a well-regarded open-source library in computer graphics, renowned for its comprehensive rendering capabilities. Two key components in PBRT’s input pipeline are the <code class="language-plaintext highlighter-rouge">Tokenizer</code> and <code class="language-plaintext highlighter-rouge">ParserTarget</code>. Together, they enable the parsing and interpretation of scene descriptions. This post delves into their design, functionality, and interplay, showcasing PBRT’s sophisticated input processing mechanism.</p> <hr/> <h2 id="understanding-the-tokenizer">Understanding the Tokenizer</h2> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> class converts raw input streams into manageable units called tokens. Alongside the <code class="language-plaintext highlighter-rouge">Token</code> structure, it performs lexical analysis, the first step in parsing scene descriptions.</p> <h3 id="the-token-structure">The <code class="language-plaintext highlighter-rouge">Token</code> Structure</h3> <p>The <code class="language-plaintext highlighter-rouge">Token</code> structure represents an individual piece of meaningful data extracted from the input. Its primary components include:</p> <ul> <li><strong><code class="language-plaintext highlighter-rouge">std::string_view token</code></strong>: A lightweight, non-owning reference to the token’s string content.</li> <li><strong><code class="language-plaintext highlighter-rouge">FileLoc loc</code></strong>: An object that records the file, line, and column where the token originates, aiding in debugging and error reporting.</li> </ul> <h4 id="key-features">Key Features</h4> <ol> <li><strong>Efficient String Handling</strong>: By leveraging <code class="language-plaintext highlighter-rouge">std::string_view</code>, it minimizes unnecessary string copying.</li> <li><strong>Error Context</strong>: The <code class="language-plaintext highlighter-rouge">FileLoc</code> ensures precise error reporting by providing detailed location information.</li> </ol> <h4 id="example">Example</h4> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Token</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">token</span><span class="p">,</span> <span class="n">FileLoc</span> <span class="n">loc</span><span class="p">)</span> <span class="o">:</span> <span class="n">token</span><span class="p">(</span><span class="n">token</span><span class="p">),</span> <span class="n">loc</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">ToString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="o">+</span> <span class="s">" at "</span> <span class="o">+</span> <span class="n">loc</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>This design ensures tokens are both lightweight and contextually rich.</p> <h3 id="the-tokenizer-class">The <code class="language-plaintext highlighter-rouge">Tokenizer</code> Class</h3> <h4 id="core-responsibilities">Core Responsibilities</h4> <ol> <li><strong>Lexical Analysis</strong>: Breaks down raw input into tokens.</li> <li><strong>Error Handling</strong>: Supports user-defined callbacks for error reporting.</li> <li><strong>Stream Management</strong>: Processes input from files and strings alike.</li> </ol> <h4 id="key-methods">Key Methods</h4> <ul> <li> <p><strong>Token Extraction</strong>: The <code class="language-plaintext highlighter-rouge">Next</code> method retrieves the next token, handling whitespace, comments, and escaped characters:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pstd</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">Token</span><span class="o">&gt;</span> <span class="n">Next</span><span class="p">();</span>
</code></pre></div> </div> </li> <li> <p><strong>Factory Methods</strong>: <code class="language-plaintext highlighter-rouge">CreateFromFile</code> and <code class="language-plaintext highlighter-rouge">CreateFromString</code> initialize a <code class="language-plaintext highlighter-rouge">Tokenizer</code> for different input sources.</p> </li> <li> <p><strong>Error Callback</strong>:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">errorCallback</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="k">const</span> <span class="n">FileLoc</span> <span class="o">*</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div> </div> </li> </ul> <h4 id="efficiency-and-flexibility">Efficiency and Flexibility</h4> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> is designed for performance and adaptability, with memory-efficient string handling and support for PBRT’s custom syntax.</p> <hr/> <h2 id="exploring-the-parsertarget">Exploring the ParserTarget</h2> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> interprets tokens produced by the <code class="language-plaintext highlighter-rouge">Tokenizer</code>, converting them into structured representations of scene data. It abstracts token interpretation from PBRT’s rendering logic.</p> <h3 id="design-philosophy">Design Philosophy</h3> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> provides an interface for processing structured data, ensuring a clear separation of concerns. Its primary functions include:</p> <ol> <li><strong>Data Interpretation</strong>: Transforms token sequences into meaningful constructs like objects and materials.</li> <li><strong>Modularity</strong>: Decouples tokenization from high-level parsing and semantic processing.</li> </ol> <h3 id="key-methods-1">Key Methods</h3> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">AddShape</code></strong>: Handles shape declarations by accepting a name and parameters:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">AddShape</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">ParsedParameterVector</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">AddMaterial</code></strong>: Processes material definitions:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">AddMaterial</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">ParsedParameterVector</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">AddLight</code></strong>: Interprets light source specifications:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">AddLight</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="n">ParsedParameterVector</span> <span class="n">parameters</span><span class="p">);</span>
</code></pre></div> </div> </li> </ol> <h3 id="implementation-details">Implementation Details</h3> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> acts as a base class, enabling developers to create specialized implementations tailored to specific rendering needs. This design fosters:</p> <ul> <li><strong>Customizability</strong>: Developers can extend functionality without modifying the core implementation.</li> <li><strong>Maintainability</strong>: Encapsulation reduces dependencies and enhances code clarity.</li> </ul> <hr/> <h2 id="how-they-work-together">How They Work Together</h2> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> and <code class="language-plaintext highlighter-rouge">ParserTarget</code> collaborate in a streamlined pipeline:</p> <ol> <li><strong>Tokenization</strong>: The <code class="language-plaintext highlighter-rouge">Tokenizer</code> processes input streams and produces tokens.</li> <li><strong>Parsing</strong>: The <code class="language-plaintext highlighter-rouge">ParserTarget</code> interprets these tokens according to PBRT’s syntax.</li> <li><strong>Scene Construction</strong>: Parsed data updates PBRT’s internal representation of the scene.</li> </ol> <p>This modular design exemplifies sound software engineering, with each component fulfilling a distinct role.</p> <h3 id="comparison-to-json-or-xml">Comparison to JSON or XML</h3> <table> <thead> <tr> <th style="text-align: left">Aspect</th> <th style="text-align: center">Tokenizer in PBRT</th> <th style="text-align: right">JSON</th> <th style="text-align: right">XML</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>Syntax</strong></td> <td style="text-align: center">Custom, minimal</td> <td style="text-align: right">Rigid, hierarchical</td> <td style="text-align: right">Verbose, hierarchical</td> </tr> <tr> <td style="text-align: left"><strong>Readability</strong></td> <td style="text-align: center">High for humans</td> <td style="text-align: right">Medium</td> <td style="text-align: right">Low</td> </tr> <tr> <td style="text-align: left"><strong>Extensibility</strong></td> <td style="text-align: center">Highly flexible</td> <td style="text-align: right">Moderate</td> <td style="text-align: right">Moderate</td> </tr> <tr> <td style="text-align: left"><strong>Parsing Complexity</strong></td> <td style="text-align: center">Lightweight</td> <td style="text-align: right">Moderate</td> <td style="text-align: right">Heavy</td> </tr> <tr> <td style="text-align: left"><strong>Expressiveness</strong></td> <td style="text-align: center">Domain-specific</td> <td style="text-align: right">Generic</td> <td style="text-align: right">Generic</td> </tr> <tr> <td style="text-align: left"><strong>Error Handling</strong></td> <td style="text-align: center">Customized</td> <td style="text-align: right">Standardized</td> <td style="text-align: right">Standardized</td> </tr> </tbody> </table> <h3 id="why-not-json-or-xml">Why Not JSON or XML?</h3> <p>PBRT’s scene descriptions require a format optimized for:</p> <ul> <li>Inline mathematical expressions.</li> <li>Metadata and comments.</li> <li>Compact, domain-specific configurations.</li> </ul> <p>General-purpose formats like JSON or XML are less suited for these needs, making a custom <code class="language-plaintext highlighter-rouge">Tokenizer</code> more appropriate.</p> <hr/> <h2 id="design-patterns-and-principles">Design Patterns and Principles</h2> <h3 id="factory-method-pattern">Factory Method Pattern</h3> <p>Used in the <code class="language-plaintext highlighter-rouge">Tokenizer</code> for creating instances from different input sources.</p> <h3 id="strategy-pattern">Strategy Pattern</h3> <p>Error callbacks decouple error handling from tokenization logic.</p> <h3 id="single-responsibility-principle">Single Responsibility Principle</h3> <ul> <li><code class="language-plaintext highlighter-rouge">Tokenizer</code>: Handles lexical analysis.</li> <li><code class="language-plaintext highlighter-rouge">ParserTarget</code>: Focuses on semantic interpretation.</li> </ul> <h3 id="openclosed-principle">Open/Closed Principle</h3> <p>The <code class="language-plaintext highlighter-rouge">ParserTarget</code> allows new functionality through inheritance without modifying the base class.</p> <hr/> <h2 id="lessons-for-c-developers">Lessons for C++ Developers</h2> <ol> <li><strong>Efficient String Management</strong>: Leverage <code class="language-plaintext highlighter-rouge">std::string_view</code> for minimal overhead.</li> <li><strong>Contextual Error Reporting</strong>: Use tools like <code class="language-plaintext highlighter-rouge">FileLoc</code> for precise debugging.</li> <li><strong>Separation of Concerns</strong>: Design modular systems by clearly defining component responsibilities.</li> <li><strong>Extensibility</strong>: Utilize base classes and virtual methods for adaptable and maintainable code.</li> </ol> <hr/> <h2 id="conclusion">Conclusion</h2> <p>The <code class="language-plaintext highlighter-rouge">Tokenizer</code> and <code class="language-plaintext highlighter-rouge">ParserTarget</code> exemplify PBRT’s thoughtful design, enabling efficient and flexible input processing. By separating tokenization and parsing, these components ensure clarity and adaptability. They serve as excellent case studies for C++ developers seeking to master modern software architecture, particularly in the domain of computer graphics.</p>]]></content><author><name></name></author><category term="C++"/><category term="ModernC++"/><category term="Pbrt"/><summary type="html"><![CDATA[PBRT (Physically Based Rendering Toolkit) is a well-regarded open-source library in computer graphics, renowned for its comprehensive rendering capabilities. Two key components in PBRT’s input pipeline are the Tokenizer and ParserTarget. Together, they enable the parsing and interpretation of scene descriptions. This post delves into their design, functionality, and interplay, showcasing PBRT’s sophisticated input processing mechanism.]]></summary></entry><entry><title type="html">DDG Introduction</title><link href="https://pasu.github.io/blog/2025/DDG_Intro/" rel="alternate" type="text/html" title="DDG Introduction"/><published>2025-01-02T17:27:00+00:00</published><updated>2025-01-02T17:27:00+00:00</updated><id>https://pasu.github.io/blog/2025/DDG_Intro</id><content type="html" xml:base="https://pasu.github.io/blog/2025/DDG_Intro/"><![CDATA[<p>“Life would be easier if the world is continuous.”</p> <h2 id="introduction">Introduction</h2> <p>Have you ever wondered how computers understand shapes and curves? Differential geometry, which traditionally deals with smooth curves and surfaces, might seem far removed from the pixelated and polygonal world of computers. This is where <strong>Discrete Differential Geometry (DDG)</strong> comes in: it bridges the gap between smooth mathematics and computational practicality. Let’s explore what differential geometry and DDG are, their differences, the grand vision of DDG, and an example to make things concrete.</p> <hr/> <h2 id="what-is-differential-geometry">What is Differential Geometry?</h2> <p><strong>Differential geometry</strong> is the mathematical study of smooth shapes like curves and surfaces. It explores how curves, surfaces, and higher-dimensional objects behave locally and globally. Using tools like calculus, it helps answer questions such as:</p> <ul> <li><strong>Curvature:</strong> How much does a curve bend at a specific point?</li> <li><strong>Tangent spaces:</strong> What does a surface look like if you zoom in infinitely close?</li> <li><strong>Manifold</strong>: What are generalized spaces that locally resemble Euclidean spaces?</li> <li><strong>Geodesics:</strong> What is the shortest path between two points on a curved surface?</li> </ul> <p>Imagine drawing a perfect circle on paper and analyzing its smooth properties. Differential geometry provides the theoretical framework for such analysis and has applications in physics, general relativity, and engineering.</p> <hr/> <h2 id="what-is-discrete-differential-geometry">What is Discrete Differential Geometry?</h2> <p><strong>Discrete differential geometry</strong> (DDG) adapts the principles of differential geometry to shapes made of small, discrete parts, like triangles in a mesh or straight edges in a curve. Instead of working with smooth functions and infinitesimal changes, DDG relies on:</p> <ul> <li><strong>Angles between edges</strong> to measure bending.</li> <li><strong>Lengths of edges</strong> to describe shapes.</li> <li><strong>Simple computational rules</strong> that approximate smooth properties.</li> </ul> <p>Think of it like replacing a perfect circle with a polygon made of straight-line segments and then studying the polygon. DDG is particularly useful in computer graphics, simulations, and architectural design.</p> <hr/> <h2 id="the-grand-vision-of-ddg">The Grand Vision of DDG</h2> <p>The goal of DDG is to <strong>translate the tools of differential geometry into a language that computers can use.</strong> This involves creating discrete versions of smooth concepts, enabling practical computation without losing essential geometric properties.</p> <p>This translation involves trade-offs, as no single discrete definition captures all aspects of its smooth counterpart. The approach depends on the specific application: some might prioritize accuracy, while others prioritize simplicity or speed.</p> <hr/> <h2 id="how-ddg-defines-discrete-geometry">How DDG Defines Discrete Geometry</h2> <p>DDG often follows these steps to adapt smooth concepts:</p> <ol> <li><strong>Start with a smooth definition.</strong> For example, curvature in the smooth case measures how much a curve bends.</li> <li><strong>Explore multiple smooth equivalents.</strong> Curvature can be described as the rate of change of the tangent or as the reciprocal of the radius of the osculating circle.</li> <li><strong>Translate these definitions to discrete settings.</strong> For a polygonal curve, curvature could be the turning angle at a vertex or the change in edge lengths when adjusted.</li> <li><strong>Choose the most suitable definition.</strong> The choice depends on what properties matter most for the application, like computational efficiency or fidelity to smooth geometry.</li> </ol> <hr/> <h2 id="an-example-curvature-of-a-curve">An Example: Curvature of a Curve</h2> <ol> <li> <p><strong>Smooth Case:</strong> In differential geometry, the curvature of a smooth curve measures how sharply it bends. For a circle, the curvature is the same everywhere and equals, where is the radius.</p> </li> <li> <p><strong>Discrete Case:</strong> For a polygonal curve made of straight edges:</p> <ul> <li>Curvature at a vertex can be defined as the angle between two connected edges (“<strong>turning angle</strong>”).</li> <li>Alternatively, it could be based on how the total edge length changes when the curve is adjusted (“<strong>length variation</strong>”).</li> </ul> </li> </ol> <p>Both methods are valid but have different strengths. For instance, turning angles are easier to compute, while length variation might better approximate smooth properties.</p> <hr/> <h2 id="why-does-ddg-matter">Why Does DDG Matter?</h2> <p>DDG allows us to:</p> <ul> <li>Simulate physical processes like heat flow or surface deformation.</li> <li>Create detailed 3D models for movies and games.</li> <li>Optimize architectural designs for aesthetics and efficiency.</li> </ul> <p>By bridging smooth mathematics and discrete computation, DDG helps bring complex geometry into the digital age.</p> <hr/> <h2 id="conclusion">Conclusion</h2> <p>Differential geometry and DDG are like two sides of the same coin. One deals with smooth perfection, and the other brings this perfection into the computational realm. Together, they help us understand and manipulate shapes in both theoretical and practical ways.</p> <p>With its ability to approximate smooth shapes and enable computation, DDG is a powerful tool in fields ranging from graphics to engineering. And while there are trade-offs in translating smooth concepts into discrete ones, DDG’s flexibility and computational efficiency make it invaluable in today’s digital world.</p> <p>If you’ve ever admired a beautifully rendered 3D object in a game or marveled at the flowing curves of modern architecture, chances are you’ve encountered the magic of DDG in action!</p>]]></content><author><name></name></author><category term="DDG"/><category term="Geometry"/><summary type="html"><![CDATA[“Life would be easier if the world is continuous.”]]></summary></entry></feed>
---
layout: post
title: Terrain
date: 2024-05-08 11:01:00
tags: 3D GIS Virtual Earth
categories: 3DGIS
---

通过**Acquisition**（如遥感和摄影测量）以及**Processing**（如地形建模和城市建模）的数据处理，3D GIS将这些数据应用于**虚拟地球**的**渲染（Rendering）**与**分析（Analysis）**。本文介绍了地球的基础概念，阐述了如何在虚拟地球上加载地形和城市模型（多源数据），并简要概述了大气、水流等地球流体现象的基本原理。

## 地球建模

地球并不是一个完美的球体，而是一个不规则的椭球体。地球在赤道的半径略大于极地的半径，因此我们用椭球模型来表示地球的形状。这种椭球模型（例如 WGS84 模型）能比圆球模型提供更高的精度。

**1. WGS84 概述**
WGS84 是世界大地测量系统1984 (World Geodetic System 1984) 的简称，是一种用于全球导航卫星系统的标准化地理坐标系。它基于地球的椭球模型，定义了地球的形状和大小，用来精确地确定全球的坐标。

**2. 圆球与椭球**
地球的模型可以用球体或椭球体表示。球体模型较为简单，但精度不足。WGS84 使用椭球模型，将地球表示为赤道半径较长、极地半径较短的椭球体。其赤道半径约为 6378137 米，极地半径约为 6356752.3142 米。

**3. Geodetic 与 Geocentric 的区别**
- **Geodetic 坐标系**：大地坐标系下，纬度定义为垂直于椭球表面的法线与赤道平面的夹角。
- **Geocentric 坐标系**：地心坐标系下，纬度定义为从地球中心指向该点的向量与赤道平面的夹角。

两者在大部分地球表面并不相同，尤其在纬度大于45度的区域，两者的角度差异更为显著。

### 1. Geographic to WGS84
将地理坐标（经度 $\lambda$，纬度 $\phi$，高度 $h$ 转换为 WGS84 的笛卡尔坐标系$（X, Y, Z）$ 使用以下公式：

步骤：
1. 计算法线方向：

   $N(\phi) = \frac{a}{\sqrt{1 - e^2 \sin^2(\phi)}}$

   其中，$a$ 是椭球的长半轴（赤道半径），$e$ 是椭球的偏心率，计算公式为：
   
   $e = \sqrt{1 - \frac{b^2}{a^2}}$

2. 转换为笛卡尔坐标系：

   $X = (N(\phi) + h) \cos(\phi) \cos(\lambda)$

   $Y = (N(\phi) + h) \cos(\phi) \sin(\lambda)$

   $Z = \left(\left(1 - e^2\right)N(\phi) + h\right) \sin(\phi)$

   这里，$h$ 是相对于椭球表面的高度。

### 2. WGS84 to Geographic

从 WGS84 坐标系 $(X, Y, Z)$转换为地理坐标没有解析解（closed form），因此需要使用迭代方法。Newton-Raphson 方法是常用的一种快速收敛的迭代算法。

#### Newton-Raphson 方法

迭代方法旨在找到纬度 $\phi$，其基本公式为：

$\phi_{n+1} = \phi_n - \frac{f(\phi_n)}{f'(\phi_n)}$

在这个问题中，$f(\phi)$ 表示椭球表面上的几何关系，$f^\prime(\phi)$ 是该函数的导数。通过多次迭代，可以快速接近准确的纬度值。

### 3. 椭球曲线

在椭球面上计算曲线的采样点时，通常根据参数化的曲线表达式，沿曲线均匀或按特定规则分布多个点。一个常见的做法是：

1. 使用椭球的参数方程，指定起点和终点的经纬度。
2. 通过插值计算中间点的经度和纬度。
3. 对每个插值点，应用 Geographic to WGS84 的转换公式，将地理坐标转换为 WGS84 坐标系下的 $(X, Y, Z)$ 坐标。

这种方法可以确保在椭球表面上生成精确的曲线采样点，用于渲染或进一步计算。

## 精度

在渲染像虚拟地球这样的**大规模环境**时，**精度**至关重要，因为**顶点转换**和**深度缓冲**都会受到**浮点数精度限制**的影响。最常见的问题是顶点转换中的**抖动（jitter）**以及深度缓冲中的**Z-fighting**。这些问题的根源在于32位**浮点数**的有限精度，这种精度在图形应用中被广泛使用。

### 1. 简述顶点和深度精度问题
- **顶点精度问题**：由于地球尺度巨大，32位浮点数无法精确表示地表的坐标，导致顶点的精度不足，表现为渲染时物体位置发生轻微抖动（jitter）。
- **深度精度问题**：在设置深度缓冲时，若近远平面范围不当，深度缓冲区的精度不足，可能导致物体之间的深度差异无法正确表示，发生 **Z-fighting** 现象。

### 2. 顶点转换的精度问题

#### **Jitter** 现象的原因：
浮点数的精度限制会导致世界坐标转换到观察者坐标时出现误差。这些误差在地表或大型场景中累积，尤其是在地球这种大尺度模型中，导致渲染时物体“抖动”。

#### **消除Jitter的解决方案**：
- **相对于中心渲染** (**Rendering Relative to Center, RTC**)：通过将坐标相对于对象中心点重新计算，使数值更小，减少误差。适用于小对象，但对大对象仍可能有抖动问题。
  
- **相对于眼睛渲染** (**Rendering Relative to Eye, RTE**)：
  - **CPU上的RTE**：在CPU上使用双精度浮点数进行世界坐标到眼睛坐标的转换。这样可以消除大尺度场景中的抖动，但会带来较大的CPU计算负担。
  - **GPU上的RTE**：通过将双精度坐标分解为两个32位浮点数，可以在GPU上模拟双精度计算。这样可以大幅减少抖动，并降低CPU的计算开销。常用算法是**DSFUN90**。

**数学表达**：
对于双精度位置 $(P)$，可以将其表示为高位和低位浮点数的组合：

$P = P_{high} + P_{low}，$

其中 $( P_{high} )$ 和 $(P_{low})$ 分别表示双精度位置的高位和低位。

### 3. 深度缓冲的精度问题

#### **Z-fighting** 的原因：
由于深度缓冲的非线性特性，当场景的**近平面**设得过近或**远平面**设得过远时，深度缓冲的精度无法覆盖整个视锥，导致物体的深度无法正确区分，产生 **Z-fighting** 现象。

**解决方案**：
1. **调整近平面和远平面**：将近平面尽可能调远，远平面调近，以最大化深度缓冲的有效分辨率。

2. **对数深度缓冲** (**Logarithmic Depth Buffering**)：
   采用对数深度缓冲，可以使深度值的分布更加均匀，特别适合远距离的渲染场景。在对数深度缓冲中，深度值 $(z)$ 的存储形式为：
   
   $   z_{log} = \log(z + 1)$
   
   这种方式有效解决了远距离物体的深度精度问题。

3. **多视锥体渲染** (**Multiple Frustum Rendering**)：
   将场景划分为多个视锥体，每个视锥体有独立的深度缓冲，从而提高远近不同区域的深度精度。

4. **W-buffer**：
   **W-buffer** 是一种线性深度缓冲方式，相较于传统的Z-buffer，它直接使用世界坐标中的深度值 $(w)$，能够有效提高近距离的深度精度。不过，由于其对硬件的要求较高，使用相对较少。

### 4. 总结
- **顶点精度**问题主要通过**RTC** 和 **RTE** 技术来缓解，尤其是GPU上模拟双精度运算的**RTE**，能有效解决大尺度场景中的抖动现象。
- **深度精度**问题则依赖于更合理的近平面和远平面设置，以及使用对数深度缓冲和多视锥体渲染等技术来减少**Z-fighting**。

通过结合以上技术，虚拟地球引擎在大尺度环境中的渲染精度问题得到了有效解决，从而保证了场景的视觉稳定性和真实性。

## 地形

地球渲染的第一步就是地形渲染。地形主要基于**高度图** (height maps) 的表示方法，这种方法将每个地形点的高度值以栅格化的方式存储。高度图数据能够通过**法线计算** (normal computation) 来渲染不同的光照效果，同时使用**着色** (shading) 技术使地形表现更加逼真。此外，地形表示还可以包括体素、隐函数等其他方法，但高度图是最为常用的地形表示手段。

海量地形渲染的关键在于高效处理和显示大范围、复杂的地形数据。为了解决性能瓶颈和资源管理问题，海量地形渲染主要分为以下四个部分：**细节层次控制 (LOD)**、**预处理**、**出核渲染 (Out-of-Core Rendering)** 和 **剔除 (Culling)**。

### 1. **细节层次控制 (LOD)**

**LOD (Level of Detail)** 是渲染复杂场景时常用的技术，通过降低远距离或细节不明显的对象复杂度，来提升渲染效率。对于地形来说，LOD的实现包括以下几种方法：

- **离散LOD**：将地形分割为不同分辨率的网格，根据距离选择合适的LOD版本。较远处的地形使用低分辨率网格，近处则使用高分辨率。
  
- **连续LOD**：通过连续的细节层次切换，使得地形过渡更加平滑。通常使用**四叉树**或**八叉树**结构存储不同分辨率的地形块。

- **屏幕空间误差** (Screen-Space Error)：LOD的选择基于屏幕上像素级别的误差，确保在降低复杂度的同时，视觉效果不受影响。屏幕空间误差是根据物体与摄像机的距离、视角等参数计算的，通过限制误差范围来保证渲染质量。

**Cracking问题**：LOD的边界处常会出现裂缝（Cracking），这是由于不同细节层次之间的顶点对齐问题引起的。为了解决这个问题，通常采用**垂直裙边** (skirts) 或添加额外的顶点对齐不同LOD块的边缘。

### 2. **预处理 (Preprocessing)**

为了减少实时渲染时的计算量，在加载海量地形数据之前，预处理是必不可少的。预处理步骤包括：

- **网格简化**：通过简化算法，减少不重要的顶点或三角形数量，同时保持视觉效果。常见的简化方法包括**网格抽取**（mesh decimation）和**渐进网格**（progressive meshes）。
  
- **几何和纹理压缩**：大规模地形数据的存储和传输是一个重要的性能瓶颈，因此使用压缩技术至关重要。**几何压缩**可以通过减少顶点和面数据的存储需求来提高性能，而**纹理压缩**（如DXT格式）通过有损压缩减少内存占用和带宽消耗。

这些预处理步骤能有效降低数据的大小，并提高GPU加载和处理的速度。

### 3. **出核渲染 (Out-of-Core Rendering)**

海量地形数据通常远超系统内存容量，因此需要通过**出核渲染**技术，仅在渲染时加载当前视图需要的数据。出核渲染的关键包括：

- **分页**：地形数据被划分为多个块，并在需要时分页加载进内存。随着视角的移动，新的地形块会被逐步加载，而不需要的块则会被卸载，从而节省内存。
  
- **渐进加载**：为了避免突然出现的加载延迟，分页通常使用渐进加载方式。即先加载较低分辨率的地形数据，然后逐步替换为高分辨率数据。这种方式能够在用户移动视角时保持流畅的体验。

出核渲染确保了地形数据的实时流式加载，使得虚拟地球能够处理超出内存限制的大规模数据集。

### 4. **剔除 (Culling)**

**剔除**技术用于减少渲染不必要的地形部分，以提升性能。常见的剔除技术包括：

- **视锥剔除** (View-Frustum Culling)：只渲染视锥体内的地形部分。通过快速计算每个地形块的**边界体**（bounding volume），可以高效地剔除不在摄像机视角中的地形。
  
- **地平线剔除** (Horizon Culling)：在地球表面渲染时，许多远处的地形块可能位于地平线以下，被地球遮挡。通过地平线剔除，可以避免渲染那些不可见的地形，从而提高性能。

- **快速分层裁剪**：*平面遮蔽* 技术，层次包围体（BVH），**减少检查次数**，提升**渲染性能**（15-34%）。

- **面向包围盒裁剪**：*面向包围盒*（OBB），比传统包围球更**精确**，在**地平线以下**减少渲染，提升性能**10-50%**。

## 多源数据

多元数据的数据规范代表则是Cesium的3D Tiles和超图的S3M（我个人也曾经从事过S3M的开发工作）。3D Tiles（用于Cesium）和S3M（空间3D模型）是处理和可视化**大规模、多源3D地理空间数据**的关键格式，旨在**高效传输和渲染**巨大的3D数据集，包括**摄影测量**、BIM/CAD模型、点云和地形数据。它支持各种数据格式，并将它们融合成一个可视化层。广泛应用于**虚拟地球**、**数字孪生**和**元宇宙**项目中。

之前介绍的**城市建模**数据以**多源数据**的形式展现在**虚拟地球**上。这种数据可以看作是**地形数据**的升级版，其主要区别在于两个方面：首先是**LOD**（细节层次），多源数据覆盖特定自定义范围，具有更强的**自适应性**和局部连续性；其次是多源的处理方式更加复杂。因此，**多源数据**向下兼容地形数据，现在有趋势将地形也视为多源数据的一种形式，以实现数据层面的统一。

### **LOD（细节层次）与地形的区别**：
传统的地形LOD系统根据距离调整细节（远离摄像机时减少细节），而3D Tiles和S3M则应用了**更先进的技术**。它们使用**分层结构**和**自适应LOD**，确保在重要或近距离的地方提供最详细的渲染，而在远处则减少细节，避免系统资源过载。

这里推荐一个有意思的LOD剖分库：S2Geometry，用于通过将地球表面映射到单位球上来处理地理数据。该库采用 S2 单元来划分地球表面，将其分为一系列固定层级的正方形。这种方法使得在多种地理数据应用中，能够有效地进行数据分割和索引，适用于地图数据的**空间索引**、**区域查询**和**大规模数据处理**。通过将二维地球坐标映射到三维球面，可以高效处理海量的**地理信息系统（GIS）**数据。

### **海量数据传输和渲染**：
两种格式都注重**流式传输**，通过**瓦片化组织数据**，实现**局部加载**，减少带宽和系统资源消耗。瓦片化的流式传输对于在Web和移动应用中实时渲染**大规模数据集**至关重要，确保在**高度详细的3D环境**中进行**平滑导航**，例如整个城市或广阔的自然景观。

### **数字孪生和元宇宙应用**：
在数字孪生和元宇宙的背景下，3D Tiles和S3M支持**实时可视化**、**模拟**和**分析**大规模的地理空间数据集。这些技术使得建模和交互数字化物理环境成为可能，形成了**虚拟城市**和复杂模拟的基础，如智慧城市管理或灾害应急。

通过**瓦片化流式传输**、**自适应LOD**和**多源数据集成**，3D Tiles和S3M成为**构建元宇宙**和**数字孪生**的关键技术

另外，游戏中的**开放世界**技术和产品值得我们借鉴。通过将**数字现实**与现实世界相结合，以更广阔的视角思考，我们会发现许多有趣且有价值的事物。这种交互不仅能激发创意，还能推动我们对世界的理解与探索。

## 风场与流体模拟

城市风场，流体模拟和污染物扩散的数值模拟是实现**数字孪生**和**智慧城市管理**的重要工具。通过模拟**大气边界层**、**浮力效应**和**湍流动能**等关键物理现象，研究者能够预测污染物的扩散路径、评估建筑物风环境，并优化城市规划。这些研究不仅有助于提高城市居民的生活质量，还能为应对气候变化、制定环保政策提供科学依据。这里给出一个简单的概念总结。

1. **大气边界层（ABL）**：描述地球表面与自由大气层之间的动态过渡区域，受**摩擦力**、**热交换**和**污染物排放**等地面因素影响。ABL内风速随着高度变化，呈现**湍流和层流混合**。

2. **浮力与虚拟位温**：**浮力**使得热空气上升，冷空气下沉，影响大气湍流的形成。**虚拟位温**用于分析湿空气和干空气的密度差异，帮助更精确预测空气流动。

3. **微气象学**：研究ABL中小尺度天气现象，特别是与**地表摩擦**和**热流**相关的湍流现象。

4. **湍流动能（TKE）**：通过湍流的**涡旋运动**传递动量、热量和物质，CFD中用于模拟城市中污染物的垂直混合。

5. **中性ABL流的模拟**：在**中性条件**下模拟湍流时，风剪切和浮力共同作用。湍流模拟有助于预测高污染情况下的风速变化和扩散路径。

在**流体模拟**中，有多种经典的方法用于处理**水流**、**风场**等上述现象。以下是常见的几种模拟方法，涵盖了从粒子方法到网格方法的基本原理和应用场景。

### **1. 光滑粒子流体动力学 (Smoothed Particle Hydrodynamics, SPH)**

**SPH** 是一种基于粒子的流体模拟方法。它通过将流体分解为大量粒子，并跟踪每个粒子的运动和相互作用来模拟流体的行为。SPH 是无网格方法，它避免了对空间的明确划分，粒子之间的距离可以动态变化，这使得 SPH 非常适合处理**自由表面**、**溃坝问题**以及大变形流体问题。

**SPH 的核心方程**是基于粒子的质量、动量和能量守恒方程，并通过插值核函数将物理量扩展到整个模拟域：

$A(\mathbf{r}) = \sum_j m_j \frac{A_j}{\rho_j} W(\mathbf{r} - \mathbf{r_j}, h)$

其中，$A(\mathbf{r})$ 是任意物理量（如密度、压力），$W$ 是核函数，$h$ 是平滑长度，$m_j$ 是粒子质量，$ \rho_j $ 是粒子密度。

SPH 在模拟水流时，特别适合处理具有大规模自由表面变化的流体，比如水的溅射或泼洒。在风场模拟中，SPH 也可用于模拟局部空气流动，但由于其计算复杂度较高，通常用于小规模流动场的模拟。

### **2. 基于位置的方法 (Position Based Dynamics, PBD)**

**位置基方法**主要用于模拟柔性物体和流体，通过对粒子的位移直接进行约束处理，确保粒子系统满足一定的几何和物理约束条件。相比传统的基于力和加速度的方法，PBD 直接操作粒子的位置，这使得算法具有良好的稳定性和可控性。

**PBD 中常用的方程**是通过迭代调整粒子的位置来满足约束条件。对于流体模拟，可以通过位置修正的方式控制流体的密度，确保流体的可压缩性。

PBD 被广泛应用于**实时流体模拟**，例如游戏和交互式应用中，尤其是当流体与其他柔性物体（如布料、头发）交互时，PBD 能有效处理这些复杂的物体交互。

### **3. 矢量场法 (Vector Field Methods)**

**矢量场法**是一种基于网格的流体模拟方法，通过对空间区域进行网格划分，并在网格上定义**速度场**、**压力场**等物理量来描述流体的运动。最常见的矢量场法包括**欧拉法**和**拉格朗日法**，分别对流体运动进行欧拉视角（固定空间点）和拉格朗日视角（跟踪流体粒子）。

在矢量场法中，流体的运动受控于**纳维-斯托克斯方程**，该方程描述了粘性流体在力学和热力学作用下的运动行为：

$\frac{\partial \mathbf{u}}{\partial t} + (\mathbf{u} \cdot \nabla)\mathbf{u} = -\frac{1}{\rho}\nabla p + \nu \nabla^2 \mathbf{u} + \mathbf{f}$

其中，$ \mathbf{u} $ 是速度场，$ p $ 是压力，$ \nu $ 是流体的动力粘度，$ \mathbf{f} $ 是外力项。

矢量场方法特别适用于**大规模风场**模拟和**湍流流动**的仿真。其优势在于能够有效处理复杂的边界条件，并精确模拟风场中的涡旋、流体分离等现象。

### **4. 层次体积法 (Hierarchical Volume Methods)**

**层次体积法**是一种基于体积的流体模拟方法，采用多层次分辨率对流体进行建模。通过分层次调整网格的密度，可以在保留细节的同时减少计算量。该方法在处理**大规模流体模拟**（如海洋波浪）时表现出色。

层次体积法的核心思想是通过自适应网格细化，保证计算资源集中在感兴趣的区域，如水面附近或波浪形成区域。流体的运动仍然由**纳维-斯托克斯方程**控制，但通过网格分辨率的动态调整，可以极大减少计算复杂度。

## 个人感想

虚拟地球的构建是一项极具挑战性却充满乐趣的工作。我时常半开玩笑地说，我们所做的事情就像创世纪，只是上帝用了七天，而我们可能需要一生。我也常常思考：如果我们将视野从地球扩展到太阳系，甚至黑洞般的宇宙深处，该如何进行建模？宇宙的中心又该如何定义？像Interstellar中的黑洞模拟，究竟需要怎样的渲染技术才能还原那般壮丽的景象？正如庄子所言：“是故大知观于远近，故小而不寡，大而不多，知量无穷。”
---
layout: post
title: Terrain
date: 2024-05-08 11:01:00
tags: 3D GIS Terrain
categories: 3DGIS
---

## 地球建模

地球并不是一个完美的球体，而是一个不规则的椭球体。地球在赤道的半径略大于极地的半径，因此我们用椭球模型来表示地球的形状。这种椭球模型（例如 WGS84 模型）能比圆球模型提供更高的精度。

**1. WGS84 概述**
WGS84 是世界大地测量系统1984 (World Geodetic System 1984) 的简称，是一种用于全球导航卫星系统的标准化地理坐标系。它基于地球的椭球模型，定义了地球的形状和大小，用来精确地确定全球的坐标。

**2. 圆球与椭球**
地球的模型可以用球体或椭球体表示。球体模型较为简单，但精度不足。WGS84 使用椭球模型，将地球表示为赤道半径较长、极地半径较短的椭球体。其赤道半径约为 6378137 米，极地半径约为 6356752.3142 米。

**3. Geodetic 与 Geocentric 的区别**
- **Geodetic 坐标系**：大地坐标系下，纬度定义为垂直于椭球表面的法线与赤道平面的夹角。
- **Geocentric 坐标系**：地心坐标系下，纬度定义为从地球中心指向该点的向量与赤道平面的夹角。

两者在大部分地球表面并不相同，尤其在纬度大于45度的区域，两者的角度差异更为显著。

### 1. Geographic to WGS84
将地理坐标（经度 $\lambda$，纬度 $\phi$，高度 $h$ 转换为 WGS84 的笛卡尔坐标系$（X, Y, Z）$ 使用以下公式：

步骤：
1. 计算法线方向：
   $
   N(\phi) = \frac{a}{\sqrt{1 - e^2 \sin^2(\phi)}}
   $
   其中，$a$ 是椭球的长半轴（赤道半径），$e$ 是椭球的偏心率，计算公式为：
   $
   e = \sqrt{1 - \frac{b^2}{a^2}}
   $

2. 转换为笛卡尔坐标系：

   $
   X = (N(\phi) + h) \cos(\phi) \cos(\lambda)
   $

   $
   Y = (N(\phi) + h) \cos(\phi) \sin(\lambda)
   $

   $
   Z = \left(\left(1 - e^2\right)N(\phi) + h\right) \sin(\phi)
   $

   这里，h 是相对于椭球表面的高度。

### 2. WGS84 to Geographic

从 WGS84 坐标系 $(X, Y, Z)$转换为地理坐标没有解析解（closed form），因此需要使用迭代方法。Newton-Raphson 方法是常用的一种快速收敛的迭代算法。

#### Newton-Raphson 方法

迭代方法旨在找到纬度 $\phi$，其基本公式为：

$
\phi_{n+1} = \phi_n - \frac{f(\phi_n)}{f'(\phi_n)}
$

在这个问题中，$f(\phi)$ 表示椭球表面上的几何关系，$f^\prime(\phi)$ 是该函数的导数。通过多次迭代，可以快速接近准确的纬度值。

### 3. 椭球曲线

在椭球面上计算曲线的采样点时，通常根据参数化的曲线表达式，沿曲线均匀或按特定规则分布多个点。一个常见的做法是：

1. 使用椭球的参数方程，指定起点和终点的经纬度。
2. 通过插值计算中间点的经度和纬度。
3. 对每个插值点，应用 Geographic to WGS84 的转换公式，将地理坐标转换为 WGS84 坐标系下的 $(X, Y, Z)$ 坐标。

这种方法可以确保在椭球表面上生成精确的曲线采样点，用于渲染或进一步计算。

## 精度

在渲染像虚拟地球这样的**大规模环境**时，**精度**至关重要，因为**顶点转换**和**深度缓冲**都会受到**浮点数精度限制**的影响。最常见的问题是顶点转换中的**抖动（jitter）**以及深度缓冲中的**Z-fighting**。这些问题的根源在于32位**浮点数**的有限精度，这种精度在图形应用中被广泛使用。

### 1. 简述顶点和深度精度问题
- **顶点精度问题**：由于地球尺度巨大，32位浮点数无法精确表示地表的坐标，导致顶点的精度不足，表现为渲染时物体位置发生轻微抖动（jitter）。
- **深度精度问题**：在设置深度缓冲时，若近远平面范围不当，深度缓冲区的精度不足，可能导致物体之间的深度差异无法正确表示，发生 **Z-fighting** 现象。

### 2. 顶点转换的精度问题

#### **Jitter** 现象的原因：
浮点数的精度限制会导致世界坐标转换到观察者坐标时出现误差。这些误差在地表或大型场景中累积，尤其是在地球这种大尺度模型中，导致渲染时物体“抖动”。

#### **消除Jitter的解决方案**：
- **相对于中心渲染** (**Rendering Relative to Center, RTC**)：通过将坐标相对于对象中心点重新计算，使数值更小，减少误差。适用于小对象，但对大对象仍可能有抖动问题。
  
- **相对于眼睛渲染** (**Rendering Relative to Eye, RTE**)：
  - **CPU上的RTE**：在CPU上使用双精度浮点数进行世界坐标到眼睛坐标的转换。这样可以消除大尺度场景中的抖动，但会带来较大的CPU计算负担。
  - **GPU上的RTE**：通过将双精度坐标分解为两个32位浮点数，可以在GPU上模拟双精度计算。这样可以大幅减少抖动，并降低CPU的计算开销。常用算法是**DSFUN90**。

**数学表达**：
对于双精度位置 $(P)$，可以将其表示为高位和低位浮点数的组合：

$
P = P_{high} + P_{low}，
$

其中 $( P_{high} )$ 和 $(P_{low})$ 分别表示双精度位置的高位和低位。

### 3. 深度缓冲的精度问题

#### **Z-fighting** 的原因：
由于深度缓冲的非线性特性，当场景的**近平面**设得过近或**远平面**设得过远时，深度缓冲的精度无法覆盖整个视锥，导致物体的深度无法正确区分，产生 **Z-fighting** 现象。

**解决方案**：
1. **调整近平面和远平面**：将近平面尽可能调远，远平面调近，以最大化深度缓冲的有效分辨率。

2. **对数深度缓冲** (**Logarithmic Depth Buffering**)：
   采用对数深度缓冲，可以使深度值的分布更加均匀，特别适合远距离的渲染场景。在对数深度缓冲中，深度值 $(z)$ 的存储形式为：
   
   $
   z_{log} = \log(z + 1)
   $
   
   这种方式有效解决了远距离物体的深度精度问题。

3. **多视锥体渲染** (**Multiple Frustum Rendering**)：
   将场景划分为多个视锥体，每个视锥体有独立的深度缓冲，从而提高远近不同区域的深度精度。

4. **W-buffer**：
   **W-buffer** 是一种线性深度缓冲方式，相较于传统的Z-buffer，它直接使用世界坐标中的深度值 $(w)$，能够有效提高近距离的深度精度。不过，由于其对硬件的要求较高，使用相对较少。

### 4. 总结
- **顶点精度**问题主要通过**RTC** 和 **RTE** 技术来缓解，尤其是GPU上模拟双精度运算的**RTE**，能有效解决大尺度场景中的抖动现象。
- **深度精度**问题则依赖于更合理的近平面和远平面设置，以及使用对数深度缓冲和多视锥体渲染等技术来减少**Z-fighting**。

通过结合以上技术，虚拟地球引擎在大尺度环境中的渲染精度问题得到了有效解决，从而保证了场景的视觉稳定性和真实性。

## 地形

地球渲染的第一步就是地形渲染。地形主要基于**高度图** (height maps) 的表示方法，这种方法将每个地形点的高度值以栅格化的方式存储。高度图数据能够通过**法线计算** (normal computation) 来渲染不同的光照效果，同时使用**着色** (shading) 技术使地形表现更加逼真。此外，地形表示还可以包括体素、隐函数等其他方法，但高度图是最为常用的地形表示手段。

海量地形渲染的关键在于高效处理和显示大范围、复杂的地形数据。为了解决性能瓶颈和资源管理问题，海量地形渲染主要分为以下四个部分：**细节层次控制 (LOD)**、**预处理**、**出核渲染 (Out-of-Core Rendering)** 和 **剔除 (Culling)**。

### 1. **细节层次控制 (LOD)**

**LOD (Level of Detail)** 是渲染复杂场景时常用的技术，通过降低远距离或细节不明显的对象复杂度，来提升渲染效率。对于地形来说，LOD的实现包括以下几种方法：

- **离散LOD**：将地形分割为不同分辨率的网格，根据距离选择合适的LOD版本。较远处的地形使用低分辨率网格，近处则使用高分辨率。
  
- **连续LOD**：通过连续的细节层次切换，使得地形过渡更加平滑。通常使用**四叉树**或**八叉树**结构存储不同分辨率的地形块。

- **屏幕空间误差** (Screen-Space Error)：LOD的选择基于屏幕上像素级别的误差，确保在降低复杂度的同时，视觉效果不受影响。屏幕空间误差是根据物体与摄像机的距离、视角等参数计算的，通过限制误差范围来保证渲染质量。

**Cracking问题**：LOD的边界处常会出现裂缝（Cracking），这是由于不同细节层次之间的顶点对齐问题引起的。为了解决这个问题，通常采用**垂直裙边** (skirts) 或添加额外的顶点对齐不同LOD块的边缘。

### 2. **预处理 (Preprocessing)**

为了减少实时渲染时的计算量，在加载海量地形数据之前，预处理是必不可少的。预处理步骤包括：

- **网格简化**：通过简化算法，减少不重要的顶点或三角形数量，同时保持视觉效果。常见的简化方法包括**网格抽取**（mesh decimation）和**渐进网格**（progressive meshes）。
  
- **几何和纹理压缩**：大规模地形数据的存储和传输是一个重要的性能瓶颈，因此使用压缩技术至关重要。**几何压缩**可以通过减少顶点和面数据的存储需求来提高性能，而**纹理压缩**（如DXT格式）通过有损压缩减少内存占用和带宽消耗。

这些预处理步骤能有效降低数据的大小，并提高GPU加载和处理的速度。

### 3. **出核渲染 (Out-of-Core Rendering)**

海量地形数据通常远超系统内存容量，因此需要通过**出核渲染**技术，仅在渲染时加载当前视图需要的数据。出核渲染的关键包括：

- **分页**：地形数据被划分为多个块，并在需要时分页加载进内存。随着视角的移动，新的地形块会被逐步加载，而不需要的块则会被卸载，从而节省内存。
  
- **渐进加载**：为了避免突然出现的加载延迟，分页通常使用渐进加载方式。即先加载较低分辨率的地形数据，然后逐步替换为高分辨率数据。这种方式能够在用户移动视角时保持流畅的体验。

出核渲染确保了地形数据的实时流式加载，使得虚拟地球能够处理超出内存限制的大规模数据集。

### 4. **剔除 (Culling)**

**剔除**技术用于减少渲染不必要的地形部分，以提升性能。常见的剔除技术包括：

- **视锥剔除** (View-Frustum Culling)：只渲染视锥体内的地形部分。通过快速计算每个地形块的**边界体**（bounding volume），可以高效地剔除不在摄像机视角中的地形。
  
- **地平线剔除** (Horizon Culling)：在地球表面渲染时，许多远处的地形块可能位于地平线以下，被地球遮挡。通过地平线剔除，可以避免渲染那些不可见的地形，从而提高性能。

这些剔除技术能够显著减少不必要的渲染计算，提升大规模地形的渲染效率。

https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/

https://cesium.com/blog/2015/06/24/oriented-bounding-boxes/

多源数据

S2

Open world

Fly to the Moon


云

流体模拟

### 总结
海量地形的渲染依赖于LOD算法、出核渲染和几何clipmapping等技术，保证了在处理复杂和大规模地形时的精度和效率。Chunked LOD与几何clipmapping各有优劣，开发者通常根据实际需求混合使用这些技术，以应对虚拟地球场景的挑战。